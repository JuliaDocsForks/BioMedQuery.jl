{
    "docs": [
        {
            "location": "/", 
            "text": "BioMedQuery Julia Package\n\n\nJulia utilities to interact with BioMedical databases/APIs. Supported databases/APIS include:\n\n\nNational Library of Medicine (NLM)\n\n\n\n\nEntrez Programming Utilities \n(E-Utilities)\n\n\nUnified Medical Language System \n(UMLS)\n\n\nClinical Trials \n(clinicaltrials.gov)\n\n\n\n\n\n\nInstallation\n\n\nBioMedQuery is a registered package. To install the latest stable version, use the package manager.\n\n\nPkg.add(\nBioMedQuery\n)\n\n\n\n\n\n\nDependencies\n\n\nRegistered Packages - automatically installed\n\n\n\n\nArgParse\n\n\nSQLite\n\n\nMySQL\n\n\nGumbo\n\n\nRequests\n\n\nDataStreams\n\n\nLightXML\n\n\nRequests\n\n\nHttpCommon\n\n\nBaseTestNext\n\n\nXMLconvert\n\n\n\n\n\n\nSister Packages\n\n\n\n\nPubMedMiner\n - Executables to search PubMed, link Mesh Descriptors to to UMLS concepts and visualize results.\n\n\nXMLConvert\n - Utilities to convert, flatten and explore XML file. Useful to investigate server responses.", 
            "title": "Overview"
        }, 
        {
            "location": "/#biomedquery-julia-package", 
            "text": "Julia utilities to interact with BioMedical databases/APIs. Supported databases/APIS include:  National Library of Medicine (NLM)   Entrez Programming Utilities  (E-Utilities)  Unified Medical Language System  (UMLS)  Clinical Trials  (clinicaltrials.gov)", 
            "title": "BioMedQuery Julia Package"
        }, 
        {
            "location": "/#installation", 
            "text": "BioMedQuery is a registered package. To install the latest stable version, use the package manager.  Pkg.add( BioMedQuery )", 
            "title": "Installation"
        }, 
        {
            "location": "/#dependencies", 
            "text": "", 
            "title": "Dependencies"
        }, 
        {
            "location": "/#registered-packages-automatically-installed", 
            "text": "ArgParse  SQLite  MySQL  Gumbo  Requests  DataStreams  LightXML  Requests  HttpCommon  BaseTestNext  XMLconvert", 
            "title": "Registered Packages - automatically installed"
        }, 
        {
            "location": "/#sister-packages", 
            "text": "PubMedMiner  - Executables to search PubMed, link Mesh Descriptors to to UMLS concepts and visualize results.  XMLConvert  - Utilities to convert, flatten and explore XML file. Useful to investigate server responses.", 
            "title": "Sister Packages"
        }, 
        {
            "location": "/entrez/", 
            "text": "Julia interface to \nEntrez Utilities API\n.\n\n\nFor executables that use this package to search PubMed, see the sister package \nPubMedMiner\n\n\n\n\nImport Module\n\n\nusing BioMedQuery.Entrez\n\n\n\n\nThe following E-utils functions have been implemented:\n\n\n\n\nESearch\n\n\nEFetch\n\n\nELink\n\n\nESummary\n\n\n\n\nThe following utility functions are available to handle and store NCBI responses\n\n\n\n\nEParse\n - Convert XML response to Julia Dict\n\n\nSaving NCBI Responses to XML\n\n\nSaving EFetch to a SQLite database\n\n\nSaving EFetch to a MySQL database\n\n\n\n\nThe following utility functions are available to query the database\n\n\n\n\nAll PMIDs\n\n\nAll MESH descriptors for an article\n\n\n\n\n\n\nESearch\n\n\n#\n\n\nBioMedQuery.Entrez.esearch\n \n \nMethod\n.\n\n\nesearch(search_dict)\n\n\n\n\nRequest list of UIDs matiching a query - see \nNCBI Entrez:Esearch\n\n\nArguments\n\n\n\n\nsearch_dic::Dict\n: dictionary specifying search criteria\n\n\n\n\nOutput\n\n\n\n\n::String\n: XML response from NCBI\n\n\n\n\nExample\n\n\nsearch_dic = Dict(\ndb\n=\npubmed\n, \nterm\n =\n search_term,\n\nretstart\n =\n 0, \nretmax\n=\n5, \ntool\n =\nBioJulia\n,\n\nemail\n =\n \nemail\n)\nesearch_response = esearch(search_dic)\n\n\n\n\nNote\n\n\n\n\nemail must be a valid email address (otherwise pubmed will block you)\n\n\nsearch_term corresponds to a valid \nPubMed Search\n. It may contain one or more filtering criteria using AND/OR.\n\n\n\n\nFor instance:\n\n\nsearch_term = (asthma[MeSH Terms]) AND (\"2001/01/29\"[Date - Publication] : \"2010\"[Date - Publication])\n.\n\n\nsource\n\n\n\n\nEFetch\n\n\n#\n\n\nBioMedQuery.Entrez.efetch\n \n \nMethod\n.\n\n\nefetch(fetch_dic, id_list)\n\n\n\n\nRetrieve data records from a list of UIDs - see \nNCBI Entrez: EFetch\n\n\nArguments\n\n\n\n\nfetch_dic::Dict\n - Dictionary specifying fetch criteria\n\n\nid_list::Array\n - List of ids e.g those embedded in response from esearch\n\n\n\n\nResults\n\n\n\n\n::String\n - XML response from NCBI\n\n\n\n\nExample\n\n\n# get the list of ids\nif !haskey(esearch_dict, \nIdList\n)\n  error(\nError: IdList not found\n)\nend\n\nids = []\n\nfor id_node in esearch_dict[\nIdList\n][1][\nId\n]\n  push!(ids, id_node)\nend\n\n# define the fetch dictionary\nfetch_dic = Dict(\ndb\n=\npubmed\n,\ntool\n =\nBioJulia\n,\n\nemail\n =\n email, \nretmode\n =\n \nxml\n, \nrettype\n=\nnull\n)\n\n# fetch\nefetch_response = efetch(fetch_dic, ids)\n\n\n\n\nsource\n\n\n\n\nELink\n\n\n#\n\n\nBioMedQuery.Entrez.elink\n \n \nMethod\n.\n\n\nelink(elink_dict)\n\n\n\n\nLists, checks or returns UIDs linked to an input list of UIDs in the same or different Entrez database. For more info see \nNCBI Entrez:ELink\n\n\nArguments\n\n\n\n\nelink_dict::Dict\n: dictionary specifying elink inputs as credentials, ids...\n\n\n\n\nOutput\n\n\n\n\n::String\n: XML response from NCBI\n\n\n\n\nExample\n\n\npmid = \n19304878\n\nelink_dict = Dict(\ndbfrom\n =\npubmed\n, \nid\n =\n pmid,\n                  \nlinkname\n =\n \npubmed_pubmed\n, \nemail\n=\nemail)\nelink_response = elink(elink_dict)\n\n\n\n\nsource\n\n\n\n\nESummary\n\n\n#\n\n\nBioMedQuery.Entrez.esummary\n \n \nMethod\n.\n\n\nesummary(esummary_dict)\n\n\n\n\nReturn document summaries for a list of input UIDs. For more info see \nNCBI Entrez:ESummary\n\n\nArguments\n\n\n\n\nesummary_dict::Dict\n: dictionary specifying esummary inputs as credentials, ids...\n\n\n\n\nOutput\n\n\n\n\n::String\n: XML response from NCBI\n\n\n\n\nExample\n\n\npmid = \n30367\n\nesummary_dict = Dict(\ndb\n =\npubmed\n, \nid\n =\n pmid, \nemail\n=\nemail)\nesummary_response = esummary(esummary_dict)\n\n\n\n\nsource\n\n\n\n\nEParse\n\n\n#\n\n\nBioMedQuery.Entrez.eparse\n \n \nMethod\n.\n\n\neparse(response::String)\n\n\n\n\nConverts NCBI XML response into a Julia dictionary\n\n\nsource\n\n\n\n\nSaving NCBI Responses to XML\n\n\nYou can save directly the XML String to file using the \nXMLconvert Package\n\n\nExample\n\n\n    XMLconvert.xmlASCII2file(efetch_response, \n./efetch.xml\n)\n\n\n\n\n\n\nSaving EFetch to a SQLite database\n\n\nsave_efetch_sqlite(efetch_dict, db_config, verbose)\n\n\n\n\n\n\nSaving EFetch to a MySQL database\n\n\nsave_efetch_mysql(efetch_dict, db_config, verbose)\n\n\n\n\nThe following schema has been used to store the results. If you are interested in having this module store additional fields, feel free to open an issue\n\n\n\n\n\n\nAll PMIDs\n\n\n#\n\n\nBioMedQuery.Entrez.DB.all_pmids\n \n \nMethod\n.\n\n\nall_pmids(db)\n\n\n\n\nReturn all PMIDs stored in the \narticle\n table of the input database\n\n\nsource\n\n\n\n\nAll MESH descriptors for an article\n\n\n#\n\n\nBioMedQuery.Entrez.DB.get_article_mesh\n \n \nMethod\n.\n\n\nget_article_mesh(db, pmid)\n\n\n\n\nGet the all mesh-descriptors associated with a give article\n\n\nsource", 
            "title": "Entrez"
        }, 
        {
            "location": "/entrez/#import-module", 
            "text": "using BioMedQuery.Entrez  The following E-utils functions have been implemented:   ESearch  EFetch  ELink  ESummary   The following utility functions are available to handle and store NCBI responses   EParse  - Convert XML response to Julia Dict  Saving NCBI Responses to XML  Saving EFetch to a SQLite database  Saving EFetch to a MySQL database   The following utility functions are available to query the database   All PMIDs  All MESH descriptors for an article", 
            "title": "Import Module"
        }, 
        {
            "location": "/entrez/#esearch", 
            "text": "#  BioMedQuery.Entrez.esearch     Method .  esearch(search_dict)  Request list of UIDs matiching a query - see  NCBI Entrez:Esearch", 
            "title": "ESearch"
        }, 
        {
            "location": "/entrez/#arguments", 
            "text": "search_dic::Dict : dictionary specifying search criteria", 
            "title": "Arguments"
        }, 
        {
            "location": "/entrez/#output", 
            "text": "::String : XML response from NCBI", 
            "title": "Output"
        }, 
        {
            "location": "/entrez/#example", 
            "text": "search_dic = Dict( db = pubmed ,  term  =  search_term, retstart  =  0,  retmax = 5,  tool  = BioJulia , email  =   email )\nesearch_response = esearch(search_dic)", 
            "title": "Example"
        }, 
        {
            "location": "/entrez/#note", 
            "text": "email must be a valid email address (otherwise pubmed will block you)  search_term corresponds to a valid  PubMed Search . It may contain one or more filtering criteria using AND/OR.   For instance:  search_term = (asthma[MeSH Terms]) AND (\"2001/01/29\"[Date - Publication] : \"2010\"[Date - Publication]) .  source", 
            "title": "Note"
        }, 
        {
            "location": "/entrez/#efetch", 
            "text": "#  BioMedQuery.Entrez.efetch     Method .  efetch(fetch_dic, id_list)  Retrieve data records from a list of UIDs - see  NCBI Entrez: EFetch", 
            "title": "EFetch"
        }, 
        {
            "location": "/entrez/#arguments_1", 
            "text": "fetch_dic::Dict  - Dictionary specifying fetch criteria  id_list::Array  - List of ids e.g those embedded in response from esearch", 
            "title": "Arguments"
        }, 
        {
            "location": "/entrez/#results", 
            "text": "::String  - XML response from NCBI", 
            "title": "Results"
        }, 
        {
            "location": "/entrez/#example_1", 
            "text": "# get the list of ids\nif !haskey(esearch_dict,  IdList )\n  error( Error: IdList not found )\nend\n\nids = []\n\nfor id_node in esearch_dict[ IdList ][1][ Id ]\n  push!(ids, id_node)\nend\n\n# define the fetch dictionary\nfetch_dic = Dict( db = pubmed , tool  = BioJulia , email  =  email,  retmode  =   xml ,  rettype = null )\n\n# fetch\nefetch_response = efetch(fetch_dic, ids)  source", 
            "title": "Example"
        }, 
        {
            "location": "/entrez/#elink", 
            "text": "#  BioMedQuery.Entrez.elink     Method .  elink(elink_dict)  Lists, checks or returns UIDs linked to an input list of UIDs in the same or different Entrez database. For more info see  NCBI Entrez:ELink", 
            "title": "ELink"
        }, 
        {
            "location": "/entrez/#arguments_2", 
            "text": "elink_dict::Dict : dictionary specifying elink inputs as credentials, ids...", 
            "title": "Arguments"
        }, 
        {
            "location": "/entrez/#output_1", 
            "text": "::String : XML response from NCBI", 
            "title": "Output"
        }, 
        {
            "location": "/entrez/#example_2", 
            "text": "pmid =  19304878 \nelink_dict = Dict( dbfrom  = pubmed ,  id  =  pmid,\n                   linkname  =   pubmed_pubmed ,  email = email)\nelink_response = elink(elink_dict)  source", 
            "title": "Example"
        }, 
        {
            "location": "/entrez/#esummary", 
            "text": "#  BioMedQuery.Entrez.esummary     Method .  esummary(esummary_dict)  Return document summaries for a list of input UIDs. For more info see  NCBI Entrez:ESummary", 
            "title": "ESummary"
        }, 
        {
            "location": "/entrez/#arguments_3", 
            "text": "esummary_dict::Dict : dictionary specifying esummary inputs as credentials, ids...", 
            "title": "Arguments"
        }, 
        {
            "location": "/entrez/#output_2", 
            "text": "::String : XML response from NCBI", 
            "title": "Output"
        }, 
        {
            "location": "/entrez/#example_3", 
            "text": "pmid =  30367 \nesummary_dict = Dict( db  = pubmed ,  id  =  pmid,  email = email)\nesummary_response = esummary(esummary_dict)  source", 
            "title": "Example"
        }, 
        {
            "location": "/entrez/#eparse", 
            "text": "#  BioMedQuery.Entrez.eparse     Method .  eparse(response::String)  Converts NCBI XML response into a Julia dictionary  source", 
            "title": "EParse"
        }, 
        {
            "location": "/entrez/#saving-ncbi-responses-to-xml", 
            "text": "You can save directly the XML String to file using the  XMLconvert Package", 
            "title": "Saving NCBI Responses to XML"
        }, 
        {
            "location": "/entrez/#example_4", 
            "text": "XMLconvert.xmlASCII2file(efetch_response,  ./efetch.xml )", 
            "title": "Example"
        }, 
        {
            "location": "/entrez/#saving-efetch-to-a-sqlite-database", 
            "text": "save_efetch_sqlite(efetch_dict, db_config, verbose)", 
            "title": "Saving EFetch to a SQLite database"
        }, 
        {
            "location": "/entrez/#saving-efetch-to-a-mysql-database", 
            "text": "save_efetch_mysql(efetch_dict, db_config, verbose)  The following schema has been used to store the results. If you are interested in having this module store additional fields, feel free to open an issue", 
            "title": "Saving EFetch to a MySQL database"
        }, 
        {
            "location": "/entrez/#all-pmids", 
            "text": "#  BioMedQuery.Entrez.DB.all_pmids     Method .  all_pmids(db)  Return all PMIDs stored in the  article  table of the input database  source", 
            "title": "All PMIDs"
        }, 
        {
            "location": "/entrez/#all-mesh-descriptors-for-an-article", 
            "text": "#  BioMedQuery.Entrez.DB.get_article_mesh     Method .  get_article_mesh(db, pmid)  Get the all mesh-descriptors associated with a give article  source", 
            "title": "All MESH descriptors for an article"
        }, 
        {
            "location": "/umls/", 
            "text": "Search the Unified Medical Language System (UMLS), for more details visit the \nREST API\n.\n\n\nSearching the UMLS requires approved credentials. You can sign up [here]](https://uts.nlm.nih.gov//license.html)\n\n\nImport\n\n\nusing BioMedQuery.UMLS\n\n\n\n\n\n\nCredentials\n\n\n#\n\n\nBioMedQuery.UMLS.Credentials\n \n \nType\n.\n\n\nCredentials(user, psswd)\n\n\n\n\nsource\n\n\n\n\nSearch the UMLS\n\n\n#\n\n\nBioMedQuery.UMLS.search_umls\n \n \nMethod\n.\n\n\nsearch_umls(c::Credentials, query)\n\n\n\n\nSearch UMLS Rest API. For more info see \nUMLS_API\n\n\nArguments\n\n\n\n\nc::Credentials\n: UMLS username and password\n\n\nquery\n: UMLS query containing the search term\n\n\nversion:\n Optional - defaults to current\n\n\n\n\nOutput\n\n\n\n\nresult_pages\n: Array, where each entry is a dictionary containing a page of\n\n\n\n\nresults. e.g\n\n\nDict{AbstractString,Any} with 3 entries:\n  \"pageSize\"   =\n 25\n   \"pageNumber\" =\n 1\n  \"result\"     =\n Dict{AbstractString,Any}(\"classType\"=\n\"searchResults\",\"result\u2026\n\n\nExamples\n\n\n\njulia credentials = Credentials(user, psswd) tgt = get_tgt(credentials) term = \nobesity\n query = Dict(\nstring\n=\nterm, \nsearchType\n=\nexact\n ) all_results= search_umls(tgt, query) ```\n\n\n\na target='_blank' href='https://github.com/bcbi/BioMedQuery.jl/tree/6784d8728ec34959a797e41b8178c17a1243251d/src/UMLS/UMLS.jl#L97-L129' class='documenter-source'\nsource\n/a\nbr\n\n\n\n\na id='Best-match-CUI-1'\n/a\n\n\n## Best match CUI\n\n\na id='BioMedQuery.UMLS.best_match_cui-Tuple{Any}' href='#BioMedQuery.UMLS.best_match_cui-Tuple{Any}'\n#\n/a\n\n**`BioMedQuery.UMLS.best_match_cui`** \nmdash; *Method*.\n\n\n\n\n\n\n\nbest_match_cui(result_pages)\n\n\n\nRetrive the best match from array of all result pages\n\n###Example\n\n```julia\ncui = BioMedQuery.UMLS.best_match_cui(all_results)\n\n\n\n\nsource\n\n\n\n\nSemantic types of a CUI\n\n\n#\n\n\nBioMedQuery.UMLS.get_semantic_type\n \n \nMethod\n.\n\n\nget_semantic_type(c::Credentials, cui)\n\n\n\n\nReturn an array of the semantic types associated with a cui\n\n\nExample\n\n\ncredentials = Credentials(user, psswd)\ntgt = get_tgt(credentials)\ncui = \nC0028754\n\nsm = BioMedQuery.UMLS.get_semantic_type(tgt, cui)\n\n\n\n\nsource\n\n\n\n\nSemantic Network Database\n\n\n#\n\n\nBioMedQuery.UMLS.populate_net_mysql\n \n \nMethod\n.\n\n\npopulate_net_mysql(config; sn_version, mysql_version)\n\n\n\n\nPopulate and return a MySQL database with the UMLS Semantic Network Structure\n\n\nArguments:\n\n\n\n\nconfig:Dict()\n: Dictionary containing MySQL database information\n\n\nsn_version\n: Version of the Semantic Network (defaults to 2015AB). Available\n\n\n\n\nversions include: 2015AB (planning to include future releases)\n\n\n\n\nmysql_version:\n Supported and default version is mysql5_6\n\n\n\n\nExample:\n\n\nhost=\nlocalhost\n\nusername=\nroot\n\npassword=\n\numls_sn_dbname=\numls_sn\n\noverwrite_db=true\n\ndb_config = Dict(:host=\nhost,\n                 :dbname=\numls_sn_dbname,\n                 :username=\nusername,\n                 :pswd=\npassword,\n                 :overwrite=\noverwrite_db)\numls_sn_db= populate_net_mysql(db_config)\n\n\n\n\nsource\n\n\n\n\nSchema\n\n\nThe schema of the MySQL database of the semantic network is the following:\n\n\n\n\nNote:\n\n\nThe previous function uses the original scripts that are part of MetamorphoSys (part of the mmsys.zip downloaded \nhere\n), and the current Relational ASCII (CVS) files for the UMLS Semantic Network (obtained \nhere\n)\n\n\nFor useful information on loading your Semantic Network files into an Oracle or MySQL database, please consult the on-line documentation at:\n\n\nhttp://www.nlm.nih.gov/research/umls/implementation_resources/scripts/index.html", 
            "title": "UMLS"
        }, 
        {
            "location": "/umls/#import", 
            "text": "using BioMedQuery.UMLS", 
            "title": "Import"
        }, 
        {
            "location": "/umls/#credentials", 
            "text": "#  BioMedQuery.UMLS.Credentials     Type .  Credentials(user, psswd)  source", 
            "title": "Credentials"
        }, 
        {
            "location": "/umls/#search-the-umls", 
            "text": "#  BioMedQuery.UMLS.search_umls     Method .  search_umls(c::Credentials, query)  Search UMLS Rest API. For more info see  UMLS_API", 
            "title": "Search the UMLS"
        }, 
        {
            "location": "/umls/#arguments", 
            "text": "c::Credentials : UMLS username and password  query : UMLS query containing the search term  version:  Optional - defaults to current", 
            "title": "Arguments"
        }, 
        {
            "location": "/umls/#output", 
            "text": "result_pages : Array, where each entry is a dictionary containing a page of   results. e.g  Dict{AbstractString,Any} with 3 entries:\n  \"pageSize\"   =  25\n   \"pageNumber\" =  1\n  \"result\"     =  Dict{AbstractString,Any}(\"classType\"= \"searchResults\",\"result\u2026", 
            "title": "Output"
        }, 
        {
            "location": "/umls/#examples", 
            "text": "julia credentials = Credentials(user, psswd) tgt = get_tgt(credentials) term =  obesity  query = Dict( string = term,  searchType = exact  ) all_results= search_umls(tgt, query) ``` a target='_blank' href='https://github.com/bcbi/BioMedQuery.jl/tree/6784d8728ec34959a797e41b8178c17a1243251d/src/UMLS/UMLS.jl#L97-L129' class='documenter-source' source /a br  a id='Best-match-CUI-1' /a \n\n## Best match CUI a id='BioMedQuery.UMLS.best_match_cui-Tuple{Any}' href='#BioMedQuery.UMLS.best_match_cui-Tuple{Any}' # /a \n**`BioMedQuery.UMLS.best_match_cui`**  mdash; *Method*.  best_match_cui(result_pages)  \nRetrive the best match from array of all result pages\n\n###Example\n\n```julia\ncui = BioMedQuery.UMLS.best_match_cui(all_results)  source", 
            "title": "Examples"
        }, 
        {
            "location": "/umls/#semantic-types-of-a-cui", 
            "text": "#  BioMedQuery.UMLS.get_semantic_type     Method .  get_semantic_type(c::Credentials, cui)  Return an array of the semantic types associated with a cui", 
            "title": "Semantic types of a CUI"
        }, 
        {
            "location": "/umls/#example", 
            "text": "credentials = Credentials(user, psswd)\ntgt = get_tgt(credentials)\ncui =  C0028754 \nsm = BioMedQuery.UMLS.get_semantic_type(tgt, cui)  source", 
            "title": "Example"
        }, 
        {
            "location": "/umls/#semantic-network-database", 
            "text": "#  BioMedQuery.UMLS.populate_net_mysql     Method .  populate_net_mysql(config; sn_version, mysql_version)  Populate and return a MySQL database with the UMLS Semantic Network Structure  Arguments:   config:Dict() : Dictionary containing MySQL database information  sn_version : Version of the Semantic Network (defaults to 2015AB). Available   versions include: 2015AB (planning to include future releases)   mysql_version:  Supported and default version is mysql5_6   Example:  host= localhost \nusername= root \npassword= \numls_sn_dbname= umls_sn \noverwrite_db=true\n\ndb_config = Dict(:host= host,\n                 :dbname= umls_sn_dbname,\n                 :username= username,\n                 :pswd= password,\n                 :overwrite= overwrite_db)\numls_sn_db= populate_net_mysql(db_config)  source", 
            "title": "Semantic Network Database"
        }, 
        {
            "location": "/umls/#schema", 
            "text": "The schema of the MySQL database of the semantic network is the following:", 
            "title": "Schema"
        }, 
        {
            "location": "/umls/#note", 
            "text": "The previous function uses the original scripts that are part of MetamorphoSys (part of the mmsys.zip downloaded  here ), and the current Relational ASCII (CVS) files for the UMLS Semantic Network (obtained  here )  For useful information on loading your Semantic Network files into an Oracle or MySQL database, please consult the on-line documentation at:  http://www.nlm.nih.gov/research/umls/implementation_resources/scripts/index.html", 
            "title": "Note:"
        }, 
        {
            "location": "/ct/", 
            "text": "Submit and save queries to \nclinicaltrials.gov\n\n\nImport\n\n\nusing NLM.CT\n\n\n\n\n\n\nSearch and save\n\n\n\n\nCreate a query:\n\n\nquery = Dict(\nterm\n =\n \nacne\n, \nage\n=\nInt(CT.child), \nlocn\n =\n \nNew York, NY\n)\n\n\n\n\nNote: The term can also indicate joint searches, e.g.\n\n\nterm\n =\n \naspirin OR ibuprofen\n\n\n\n\n\n\n\nSubmit and save:\n\n\nfout= \n./test_CT_search.zip\n\nstatus = NLM.CT.search_ct(query, fout;)", 
            "title": "Clinical Trials"
        }, 
        {
            "location": "/ct/#import", 
            "text": "using NLM.CT", 
            "title": "Import"
        }, 
        {
            "location": "/ct/#search-and-save", 
            "text": "", 
            "title": "Search and save"
        }, 
        {
            "location": "/ct/#create-a-query", 
            "text": "query = Dict( term  =   acne ,  age = Int(CT.child),  locn  =   New York, NY )  Note: The term can also indicate joint searches, e.g.  term  =   aspirin OR ibuprofen", 
            "title": "Create a query:"
        }, 
        {
            "location": "/ct/#submit-and-save", 
            "text": "fout=  ./test_CT_search.zip \nstatus = NLM.CT.search_ct(query, fout;)", 
            "title": "Submit and save:"
        }, 
        {
            "location": "/processes/", 
            "text": "This module provides common processes/workflows when using the BioMedQuery utilities. For instance, searching PubMed, requires calling the NCBI e-utils in a particular order. After the search, the results are often saved to the database. This module contains pre-assembled functions performing all necessary steps. To see sample scripts that use this processes, refer to the following \nsection\n\n\nImport\n\n\nusing BioMedQuery.Processes\n\n\n\n\n\n\nIndex\n\n\n\n\nBioMedQuery.Processes.export_citation\n\n\nBioMedQuery.Processes.export_citation\n\n\nBioMedQuery.Processes.map_mesh_to_umls!\n\n\nBioMedQuery.Processes.map_mesh_to_umls_async!\n\n\nBioMedQuery.Processes.pubmed_search_and_save\n\n\nBioMedQuery.Processes.umls_semantic_occurrences\n\n\n\n\n\n\nFunctions\n\n\n#\n\n\nBioMedQuery.Processes.export_citation\n \n \nFunction\n.\n\n\nexport_citation(entrez_email, pmids::Vector{Int64}, citation_type, output_file,verbose)\n\n\n\n\nExport, to an output file, the citation for collection of PubMed articles identified by the given pmids\n\n\nArguments\n\n\n\n\ncitation_type::String\n: At the moment supported types include: \"endnote\"\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.Processes.export_citation\n \n \nFunction\n.\n\n\nexport_citation(entrez_email, pmid::Int64, citation_type, output_file,verbose)\n\n\n\n\nExport, to an output file, the citation for PubMed article identified by the given pmid\n\n\nArguments\n\n\n\n\ncitation_type::String\n: At the moment supported types include: \"endnote\"\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.Processes.map_mesh_to_umls!\n \n \nMethod\n.\n\n\nmap_mesh_to_umls!(db, c::Credentials)\n\n\nBuild and store in the given database a map from MESH descriptors to UMLS Semantic Concepts\n\n\nArguments\n\n\n\n\ndb\n: Database. Must contain TABLE:mesh_descriptor. For each of the\n\n\n\n\ndescriptors in that table, search and insert the associated semantic concepts into a new (cleared) TABLE:mesh2umls\n\n\n\n\nc::Credentials\n: UMLS username and password\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.Processes.map_mesh_to_umls_async!\n \n \nMethod\n.\n\n\nmap_mesh_to_umls_async!(db, c::Credentials; timeout, append_results, verbose) Build (using async UMLS-API calls) and store in the given database a map from MESH descriptors to UMLS Semantic Concepts. For large queies this function will be faster than it's synchrounous counterpart\n\n\nArguments\n\n\n\n\ndb\n: Database. Must contain TABLE:mesh_descriptor. For each of the\n\n\n\n\ndescriptors in that table, search and insert the associated semantic concepts into a new (cleared) TABLE:mesh2umls\n\n\n\n\nc::Credentials\n: UMLS username and password\n\n\nappend_results::Bool\n : If false a NEW and EMPTY mesh2umls database table in creted\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.Processes.pubmed_search_and_save\n \n \nFunction\n.\n\n\npubmed_search_and_save(email, search_term, article_max::Int64, db_path, verbose=false)\n\n\nArguments\n\n\n\n\nemail: valid email address (otherwise pubmed will block you)\n\n\nsearch_term : search string to submit to PubMed\n\n\n\n\ne.g (asthma[MeSH Terms]) AND (\"2001/01/29\"[Date - Publication] : \"2010\"[Date - Publication]) see http://www.ncbi.nlm.nih.gov/pubmed/advanced for help constructing the string\n\n\n\n\narticle_max : maximum number of articles to return. Defaults to 600,000\n\n\ndb_path: path to output database\n\n\nverbose: if true, the NCBI xml response files are saved to current directory\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.Processes.umls_semantic_occurrences\n \n \nMethod\n.\n\n\numls_semantic_occurrences(db, umls_semantic_type)\n\n\nReturn a sparse matrix indicating the presence of MESH descriptors associated with a given umls semantic type in all articles of the input database\n\n\nOutput\n\n\n\n\ndes_ind_dict\n: Dictionary matching row number to descriptor names\n\n\ndisease_occurances\n : Sparse matrix. The columns correspond to a feature\n\n\n\n\nvector, where each row is a MESH descriptor. There are as many columns as articles. The occurance/abscense of a descriptor is labeled as 1/0\n\n\nsource", 
            "title": "Processes/Workflows"
        }, 
        {
            "location": "/processes/#import", 
            "text": "using BioMedQuery.Processes", 
            "title": "Import"
        }, 
        {
            "location": "/processes/#index", 
            "text": "BioMedQuery.Processes.export_citation  BioMedQuery.Processes.export_citation  BioMedQuery.Processes.map_mesh_to_umls!  BioMedQuery.Processes.map_mesh_to_umls_async!  BioMedQuery.Processes.pubmed_search_and_save  BioMedQuery.Processes.umls_semantic_occurrences", 
            "title": "Index"
        }, 
        {
            "location": "/processes/#functions", 
            "text": "#  BioMedQuery.Processes.export_citation     Function .  export_citation(entrez_email, pmids::Vector{Int64}, citation_type, output_file,verbose)  Export, to an output file, the citation for collection of PubMed articles identified by the given pmids  Arguments   citation_type::String : At the moment supported types include: \"endnote\"   source  #  BioMedQuery.Processes.export_citation     Function .  export_citation(entrez_email, pmid::Int64, citation_type, output_file,verbose)  Export, to an output file, the citation for PubMed article identified by the given pmid  Arguments   citation_type::String : At the moment supported types include: \"endnote\"   source  #  BioMedQuery.Processes.map_mesh_to_umls!     Method .  map_mesh_to_umls!(db, c::Credentials)  Build and store in the given database a map from MESH descriptors to UMLS Semantic Concepts", 
            "title": "Functions"
        }, 
        {
            "location": "/processes/#arguments", 
            "text": "db : Database. Must contain TABLE:mesh_descriptor. For each of the   descriptors in that table, search and insert the associated semantic concepts into a new (cleared) TABLE:mesh2umls   c::Credentials : UMLS username and password   source  #  BioMedQuery.Processes.map_mesh_to_umls_async!     Method .  map_mesh_to_umls_async!(db, c::Credentials; timeout, append_results, verbose) Build (using async UMLS-API calls) and store in the given database a map from MESH descriptors to UMLS Semantic Concepts. For large queies this function will be faster than it's synchrounous counterpart", 
            "title": "Arguments"
        }, 
        {
            "location": "/processes/#arguments_1", 
            "text": "db : Database. Must contain TABLE:mesh_descriptor. For each of the   descriptors in that table, search and insert the associated semantic concepts into a new (cleared) TABLE:mesh2umls   c::Credentials : UMLS username and password  append_results::Bool  : If false a NEW and EMPTY mesh2umls database table in creted   source  #  BioMedQuery.Processes.pubmed_search_and_save     Function .  pubmed_search_and_save(email, search_term, article_max::Int64, db_path, verbose=false)", 
            "title": "Arguments"
        }, 
        {
            "location": "/processes/#arguments_2", 
            "text": "email: valid email address (otherwise pubmed will block you)  search_term : search string to submit to PubMed   e.g (asthma[MeSH Terms]) AND (\"2001/01/29\"[Date - Publication] : \"2010\"[Date - Publication]) see http://www.ncbi.nlm.nih.gov/pubmed/advanced for help constructing the string   article_max : maximum number of articles to return. Defaults to 600,000  db_path: path to output database  verbose: if true, the NCBI xml response files are saved to current directory   source  #  BioMedQuery.Processes.umls_semantic_occurrences     Method .  umls_semantic_occurrences(db, umls_semantic_type)  Return a sparse matrix indicating the presence of MESH descriptors associated with a given umls semantic type in all articles of the input database", 
            "title": "Arguments"
        }, 
        {
            "location": "/processes/#output", 
            "text": "des_ind_dict : Dictionary matching row number to descriptor names  disease_occurances  : Sparse matrix. The columns correspond to a feature   vector, where each row is a MESH descriptor. There are as many columns as articles. The occurance/abscense of a descriptor is labeled as 1/0  source", 
            "title": "Output"
        }, 
        {
            "location": "/examples/", 
            "text": "The \nexamples\n folder contains sample scripts demonstrating how to use BioMedQuery's pre-assembled processes/workflows. The following examples are available:\n\n\n\n\nSearch\nSave PubMed\n:\n\n\nBuild MESH-UMLS map\n:\n\n\nOccurrence Matrix\n:\n\n\nExporting Citations\n:\n\n\n\n\n\n\nRunning the scripts\n\n\nAll scripts can be called from the terminal:\n\n\njulia script_name.jl\n.\n\n\n\n\nConfiguring local variables\n\n\nLocal paths, database backends, and other variables need to be configured according to you needs, sections containing this local variables are enclosed by the comment lines\n\n\n#************************ LOCALS TO CONFIGURE!!!! **************************\n#***************************************************************************\n\n\n\n\nUser Credentials\n\n\nEmail addresses, passwords or any other type of credentials are expected to be stored in your system as environment variables.\n\n\nFrom a Julia session, you can set an environment variable using\n\n\nENV[\"MY_PSWD\"] = \"MyPsWd\"\n\n\nHowever, for this variable to be permanently available, you need to add that line to your \n~/.juliarc.jl\n file.\n\n\n\n\nSearch\nSave PubMed\n\n\nSee source file - \npubmed_search_and_save.jl\n\n\nIt is common to search PubMed for a given number, or all articles associated with a search term, and further store the results to a database, xml or exporting to a citation-style document.\n\n\nThe script \npubmed_search_and_save.jl\n can achieve all that.\n\n\nThe top of the script contains the configuration of the search term, the maximum number of articles to fetch and the format for saving the results. Depending on the \"exporting format\", there will be other local variables to configure. The results can be saved as:\n\n\n\n\nMySQL/SQLite database\n\n\nXML (raw NCBI response)\n\n\nCitations: EndNote, BibTEX\n\n\n\n\nThe main configuration looks as follows:\n\n\n#************************ LOCALS TO CONFIGURE!!!! **************************\nemail= ENV[\nNCBI_EMAIL\n] #This is an enviroment variable that you need to setup\nsearch_term=\n(obesity[MeSH Major Topic]) AND (\\\n2010\\\n[Date - Publication] : \\\n2012\\\n[Date - Publication])\n\nmax_articles = 20\noverwrite=true\nverbose = false\n\nresults_dir = \n./results\n\n\n\n#Exporting format\nusing_sqlite=false\nusing_mysql=false\nusing_endnote=false\nusing_xml=false\n\n#***************************************************************************\n\n\n\n\nUsing MySQL\n\n\nIf for instance, one wished to save the results to a MySQL database, all we need to do is to set\n\n\nusing_mysql = true\n\n\nthen, the following code would be executed:\n\n\n#************************ LOCALS TO CONFIGURE!!!! **************************\nhost=\nlocalhost\n #If want to hide - use enviroment variables instead\nmysql_usr=\nroot\n\nmysql_pswd=\n\ndbname=\npubmed_obesity_2010_2012\n\n#***************************************************************************\nconfig = Dict(:host=\nhost,\n                 :dbname=\ndbname,\n                 :username=\nmysql_usr,\n                 :pswd=\nmysql_pswd,\n                 :overwrite=\noverwrite)\n save_func = save_efetch_mysql\n\n db = pubmed_search_and_save(email, search_term, max_articles,\n save_func, config, verbose)\n\n\n\n\n\n\nBuild MESH-UMLS map\n\n\nSee source file - \npubmed_mesh_to_umls_map.jl\n\n\nAll PubMed articles are associated with MESH descriptors. This script looks for all mesh descriptors in a results database (as created in pubmed_search_and_save.jl) and finds the UMLS concept associated with that descriptor.\n\n\nAll MESH-UMLS relations are saved in a new (unless set to append) database table called MESH2UMLS.\n\n\nThe user is responsible for configuring the environment variables containing the UMLS credentials:\n\n\nuser = ENV[\nUMLS_USER\n]\npsswd = ENV[\nUMLS_PSSWD\n]\n\n\n\n\nAnd specifying the type and name of the database used to get the MESH and stored the MESH2UMLS.\n\n\n\n\nOccurrence Matrix\n\n\nSee source file - \numls_semantic_occurrences.jl\n\n\nThis script finds all MESH descriptors of a given UMLS semantic type and builds the corresponding occurrance/data matrix as follows\n\n\nSuppose we wish to find all MESH descriptors in all articles in our database associated with the UMLS Semantic Type: \"Disease or Syndrome\"\n\n\nSuppose we have a total of 4 articles and after filtering the MESH descriptors we have 3 descriptors. Further suppose that:\n\n\n\n\nThe first article is associated with \"diabetes mellitus, type 2\" and \"pediatric obesity\"\n\n\nThe second article is associated with \"pediatric obesity\"\n\n\nThe third article is associate with \"metabolic syndrome x\"\n\n\nThe fourth article is not associated with any \"Disease or Syndrome\"\n\n\n\n\nThen the Data Matrix would corresponds to\n\n\n\n\n\n\n\n\nMESH(down)/ARTICLE(right)\n\n\nA1\n\n\nA2\n\n\nA3\n\n\nA4\n\n\n\n\n\n\n\n\n\n\nmetabolic syndrome x\n\n\n0\n\n\n0\n\n\n1\n\n\n0\n\n\n\n\n\n\ndiabetes mellitus, type 2\n\n\n1\n\n\n0\n\n\n0\n\n\n0\n\n\n\n\n\n\npediatric obesity\n\n\n1\n\n\n1\n\n\n0\n\n\n0\n\n\n\n\n\n\n\n\nOutput Files\n\n\nThis script will save two files two files to disk in the specified output directory:\n\n\n\n\noccur_sp.jdl\n: Binary file containing the sparse datamatrix in variable \noccur\n\n\nlabels2ind.jdl\n: Binary file containing the row index to descriptor label dictionary inside variable \nlabels2ind\n\n\n\n\nTo load back these variable into julia use JDL package. e.g,\n\n\nusing JDL\nfile  = jldopen(\noccur_sp.jdl\n, \nr\n)\ndata_matrix = read(file, \noccur\n)\n\n\n\n\n\n\nExporting Citations\n\n\nSee source file - \npubmed_export_citations.jl\n\n\nBioMedQuery.Processes provides ready to use functions that save to EndNote/BibTEX formats the citations associated with a single PMID or a list of PMIDs. If you wish to search PubMed using a search-term and save the results as citations, refer to Examples/pubmed_search_and_save.jl\n\n\nExporting citations requires configuring Entrez, email, output file and citation type. For instance,\n\n\nusing BioMedQuery.Processes\n\nresults_dir = \n./results\n\n\n if !isdir(results_dir)\n     mkdir(results_dir)\n end\n\nemail= ENV[\nNCBI_EMAIL\n] #This is an enviroment variable that you need to setup\ncitation_type=\nendnote\n\npmid = 11748933\noutput_file=results_dir*\n/11748933.enw\n\n\nexport_citation(email, pmid, citation_type, output_file)", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/#running-the-scripts", 
            "text": "All scripts can be called from the terminal:  julia script_name.jl .", 
            "title": "Running the scripts"
        }, 
        {
            "location": "/examples/#configuring-local-variables", 
            "text": "Local paths, database backends, and other variables need to be configured according to you needs, sections containing this local variables are enclosed by the comment lines  #************************ LOCALS TO CONFIGURE!!!! **************************\n#***************************************************************************  User Credentials  Email addresses, passwords or any other type of credentials are expected to be stored in your system as environment variables.  From a Julia session, you can set an environment variable using  ENV[\"MY_PSWD\"] = \"MyPsWd\"  However, for this variable to be permanently available, you need to add that line to your  ~/.juliarc.jl  file.", 
            "title": "Configuring local variables"
        }, 
        {
            "location": "/examples/#searchsave-pubmed", 
            "text": "See source file -  pubmed_search_and_save.jl  It is common to search PubMed for a given number, or all articles associated with a search term, and further store the results to a database, xml or exporting to a citation-style document.  The script  pubmed_search_and_save.jl  can achieve all that.  The top of the script contains the configuration of the search term, the maximum number of articles to fetch and the format for saving the results. Depending on the \"exporting format\", there will be other local variables to configure. The results can be saved as:   MySQL/SQLite database  XML (raw NCBI response)  Citations: EndNote, BibTEX   The main configuration looks as follows:  #************************ LOCALS TO CONFIGURE!!!! **************************\nemail= ENV[ NCBI_EMAIL ] #This is an enviroment variable that you need to setup\nsearch_term= (obesity[MeSH Major Topic]) AND (\\ 2010\\ [Date - Publication] : \\ 2012\\ [Date - Publication]) \nmax_articles = 20\noverwrite=true\nverbose = false\n\nresults_dir =  ./results \n\n\n#Exporting format\nusing_sqlite=false\nusing_mysql=false\nusing_endnote=false\nusing_xml=false\n\n#***************************************************************************", 
            "title": "Search&amp;Save PubMed"
        }, 
        {
            "location": "/examples/#using-mysql", 
            "text": "If for instance, one wished to save the results to a MySQL database, all we need to do is to set  using_mysql = true  then, the following code would be executed:  #************************ LOCALS TO CONFIGURE!!!! **************************\nhost= localhost  #If want to hide - use enviroment variables instead\nmysql_usr= root \nmysql_pswd= \ndbname= pubmed_obesity_2010_2012 \n#***************************************************************************\nconfig = Dict(:host= host,\n                 :dbname= dbname,\n                 :username= mysql_usr,\n                 :pswd= mysql_pswd,\n                 :overwrite= overwrite)\n save_func = save_efetch_mysql\n\n db = pubmed_search_and_save(email, search_term, max_articles,\n save_func, config, verbose)", 
            "title": "Using MySQL"
        }, 
        {
            "location": "/examples/#build-mesh-umls-map", 
            "text": "See source file -  pubmed_mesh_to_umls_map.jl  All PubMed articles are associated with MESH descriptors. This script looks for all mesh descriptors in a results database (as created in pubmed_search_and_save.jl) and finds the UMLS concept associated with that descriptor.  All MESH-UMLS relations are saved in a new (unless set to append) database table called MESH2UMLS.  The user is responsible for configuring the environment variables containing the UMLS credentials:  user = ENV[ UMLS_USER ]\npsswd = ENV[ UMLS_PSSWD ]  And specifying the type and name of the database used to get the MESH and stored the MESH2UMLS.", 
            "title": "Build MESH-UMLS map"
        }, 
        {
            "location": "/examples/#occurrence-matrix", 
            "text": "See source file -  umls_semantic_occurrences.jl  This script finds all MESH descriptors of a given UMLS semantic type and builds the corresponding occurrance/data matrix as follows  Suppose we wish to find all MESH descriptors in all articles in our database associated with the UMLS Semantic Type: \"Disease or Syndrome\"  Suppose we have a total of 4 articles and after filtering the MESH descriptors we have 3 descriptors. Further suppose that:   The first article is associated with \"diabetes mellitus, type 2\" and \"pediatric obesity\"  The second article is associated with \"pediatric obesity\"  The third article is associate with \"metabolic syndrome x\"  The fourth article is not associated with any \"Disease or Syndrome\"   Then the Data Matrix would corresponds to     MESH(down)/ARTICLE(right)  A1  A2  A3  A4      metabolic syndrome x  0  0  1  0    diabetes mellitus, type 2  1  0  0  0    pediatric obesity  1  1  0  0", 
            "title": "Occurrence Matrix"
        }, 
        {
            "location": "/examples/#output-files", 
            "text": "This script will save two files two files to disk in the specified output directory:   occur_sp.jdl : Binary file containing the sparse datamatrix in variable  occur  labels2ind.jdl : Binary file containing the row index to descriptor label dictionary inside variable  labels2ind   To load back these variable into julia use JDL package. e.g,  using JDL\nfile  = jldopen( occur_sp.jdl ,  r )\ndata_matrix = read(file,  occur )", 
            "title": "Output Files"
        }, 
        {
            "location": "/examples/#exporting-citations", 
            "text": "See source file -  pubmed_export_citations.jl  BioMedQuery.Processes provides ready to use functions that save to EndNote/BibTEX formats the citations associated with a single PMID or a list of PMIDs. If you wish to search PubMed using a search-term and save the results as citations, refer to Examples/pubmed_search_and_save.jl  Exporting citations requires configuring Entrez, email, output file and citation type. For instance,  using BioMedQuery.Processes\n\nresults_dir =  ./results \n\n if !isdir(results_dir)\n     mkdir(results_dir)\n end\n\nemail= ENV[ NCBI_EMAIL ] #This is an enviroment variable that you need to setup\ncitation_type= endnote \npmid = 11748933\noutput_file=results_dir* /11748933.enw \n\nexport_citation(email, pmid, citation_type, output_file)", 
            "title": "Exporting Citations"
        }, 
        {
            "location": "/dbutils/", 
            "text": "Collection of functions that extend of simplify interactions with MySQL and SQLite databases\n\n\n\n\nImport Module\n\n\nusing BioMedQuery.DBUtils\n\n\n\n\n\n\nIndex\n\n\n\n\nBioMedQuery.DBUtils.assemble_cols_and_vals\n\n\nBioMedQuery.DBUtils.assemble_cols_and_vals_select\n\n\nBioMedQuery.DBUtils.assemble_vals\n\n\nBioMedQuery.DBUtils.colname_dict\n\n\nBioMedQuery.DBUtils.db_query\n\n\nBioMedQuery.DBUtils.db_query\n\n\nBioMedQuery.DBUtils.db_select\n\n\nBioMedQuery.DBUtils.init_mysql_database\n\n\nBioMedQuery.DBUtils.insert_row!\n\n\nBioMedQuery.DBUtils.insert_row!\n\n\nBioMedQuery.DBUtils.select_all_tables\n\n\nBioMedQuery.DBUtils.select_all_tables\n\n\nBioMedQuery.DBUtils.select_columns\n\n\nBioMedQuery.DBUtils.select_columns\n\n\n\n\n\n\nFunctions\n\n\n#\n\n\nBioMedQuery.DBUtils.assemble_vals\n \n \nMethod\n.\n\n\nassemble_vals(data_values, column_names)\n\n\n\n\nGiven a Dict of values and the column names, return a single string properly formatted for a MySQL INSERT. E.g MySQL requires CHAR or other non-numeric values be passed with single quotes around them.\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.db_query\n \n \nMethod\n.\n\n\nquery_mysql(con, query_code)\n\n\n\n\nExecute a mysql command\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.db_query\n \n \nMethod\n.\n\n\nquery(db, query_code)\n\n\n\n\nExecute a SQLite command\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.db_select\n \n \nMethod\n.\n\n\nselect_(con, colnames, tablename, data_values)\n\n\n\n\nPerform: SELECT colnames tablename WHERE keys(data_values)=values(data_values)\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.init_mysql_database\n \n \nMethod\n.\n\n\ninit_mysql_database(;host = \nlocalhost\n, dbname=\ntest\n,\nusername=\nroot\n, pswd=\n, mysql_code=nothing, overwrite=false)\n\n\n\n\nCreate a MySQL database using the code inside mysql_code\n\n\nArguments\n\n\n\n\nhost\n, \ndbname\n, \nuser\n, \npswd\n\n\nmysql_code::String\n: String with MySQL code that crates all default tables\n\n\noverwrite::Bool\n : Flag, if true and dbname exists, it deletes it\n\n\n\n\nOutput\n\n\n\n\ncon\n: Database connection and table-column names map\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.insert_row!\n \n \nFunction\n.\n\n\ninsert_row!(db, tablename, values)\n\n\n\n\nInsert a row of values into the specified table for a given a MySQL database handle\n\n\nArguments:\n\n\n\n\ndb::MySQLDB\n: Database object (connection and map)\n\n\ndata_values::Dict{String, Any}\n: Array of (string) values\n\n\nverbose\n: Print debugginh info\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.insert_row!\n \n \nFunction\n.\n\n\ninsert_row!(db, tablename, values)\n\n\n\n\nInsert a row of values into the specified table for a given a SQLite database handle\n\n\nArguments:\n\n\n\n\ndb::MySQLDB\n: Database object (connection and map)\n\n\ndata_values::Dict{String, Any}\n: Array of (string) values\n\n\nverbose\n: Print debugginh info\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.assemble_cols_and_vals\n \n \nMethod\n.\n\n\nassemble_vals(data_values)\n\n\n\n\nGiven a dictionary containg (:column=\nvalue) return a single string properly formatted for a MySQL insert. E.g MySQL requires CHAR or other non-numeric values be passed with single quotes around them.\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.assemble_cols_and_vals_select\n \n \nFunction\n.\n\n\nassemble_vals(data_values)\n\n\n\n\nGiven a dictionary containg (:column=\nvalue), return a single string properly formatted for a MySQL SELECT. E.g MySQL requires CHAR or other non-numeric values be passed with single quotes around them.\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.colname_dict\n \n \nMethod\n.\n\n\ncolname_dict_(con)\n\n\n\n\nReturn a dictionary maping tables and their columns for a given MySQL-connection/SQLite-database\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.select_all_tables\n \n \nMethod\n.\n\n\nselect_all_tables_mysql(con)\n\n\n\n\nReturn an array of all tables in a given MySQL database\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.select_all_tables\n \n \nMethod\n.\n\n\nselect_all_tables_mysql(con)\n\n\n\n\nReturn an array of all tables in a given MySQL database\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.select_columns\n \n \nMethod\n.\n\n\nselect_columns_mysql(con, table)\n\n\n\n\nFor a MySQL database, return an array of all columns in the given table\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.select_columns\n \n \nMethod\n.\n\n\nselect_columns(db, table)\n\n\n\n\nReturn an array with names of columns in the given table\n\n\nsource", 
            "title": "Database Utilities"
        }, 
        {
            "location": "/dbutils/#import-module", 
            "text": "using BioMedQuery.DBUtils", 
            "title": "Import Module"
        }, 
        {
            "location": "/dbutils/#index", 
            "text": "BioMedQuery.DBUtils.assemble_cols_and_vals  BioMedQuery.DBUtils.assemble_cols_and_vals_select  BioMedQuery.DBUtils.assemble_vals  BioMedQuery.DBUtils.colname_dict  BioMedQuery.DBUtils.db_query  BioMedQuery.DBUtils.db_query  BioMedQuery.DBUtils.db_select  BioMedQuery.DBUtils.init_mysql_database  BioMedQuery.DBUtils.insert_row!  BioMedQuery.DBUtils.insert_row!  BioMedQuery.DBUtils.select_all_tables  BioMedQuery.DBUtils.select_all_tables  BioMedQuery.DBUtils.select_columns  BioMedQuery.DBUtils.select_columns", 
            "title": "Index"
        }, 
        {
            "location": "/dbutils/#functions", 
            "text": "#  BioMedQuery.DBUtils.assemble_vals     Method .  assemble_vals(data_values, column_names)  Given a Dict of values and the column names, return a single string properly formatted for a MySQL INSERT. E.g MySQL requires CHAR or other non-numeric values be passed with single quotes around them.  source  #  BioMedQuery.DBUtils.db_query     Method .  query_mysql(con, query_code)  Execute a mysql command  source  #  BioMedQuery.DBUtils.db_query     Method .  query(db, query_code)  Execute a SQLite command  source  #  BioMedQuery.DBUtils.db_select     Method .  select_(con, colnames, tablename, data_values)  Perform: SELECT colnames tablename WHERE keys(data_values)=values(data_values)  source  #  BioMedQuery.DBUtils.init_mysql_database     Method .  init_mysql_database(;host =  localhost , dbname= test ,\nusername= root , pswd= , mysql_code=nothing, overwrite=false)  Create a MySQL database using the code inside mysql_code  Arguments   host ,  dbname ,  user ,  pswd  mysql_code::String : String with MySQL code that crates all default tables  overwrite::Bool  : Flag, if true and dbname exists, it deletes it   Output   con : Database connection and table-column names map   source  #  BioMedQuery.DBUtils.insert_row!     Function .  insert_row!(db, tablename, values)  Insert a row of values into the specified table for a given a MySQL database handle  Arguments:   db::MySQLDB : Database object (connection and map)  data_values::Dict{String, Any} : Array of (string) values  verbose : Print debugginh info   source  #  BioMedQuery.DBUtils.insert_row!     Function .  insert_row!(db, tablename, values)  Insert a row of values into the specified table for a given a SQLite database handle  Arguments:   db::MySQLDB : Database object (connection and map)  data_values::Dict{String, Any} : Array of (string) values  verbose : Print debugginh info   source  #  BioMedQuery.DBUtils.assemble_cols_and_vals     Method .  assemble_vals(data_values)  Given a dictionary containg (:column= value) return a single string properly formatted for a MySQL insert. E.g MySQL requires CHAR or other non-numeric values be passed with single quotes around them.  source  #  BioMedQuery.DBUtils.assemble_cols_and_vals_select     Function .  assemble_vals(data_values)  Given a dictionary containg (:column= value), return a single string properly formatted for a MySQL SELECT. E.g MySQL requires CHAR or other non-numeric values be passed with single quotes around them.  source  #  BioMedQuery.DBUtils.colname_dict     Method .  colname_dict_(con)  Return a dictionary maping tables and their columns for a given MySQL-connection/SQLite-database  source  #  BioMedQuery.DBUtils.select_all_tables     Method .  select_all_tables_mysql(con)  Return an array of all tables in a given MySQL database  source  #  BioMedQuery.DBUtils.select_all_tables     Method .  select_all_tables_mysql(con)  Return an array of all tables in a given MySQL database  source  #  BioMedQuery.DBUtils.select_columns     Method .  select_columns_mysql(con, table)  For a MySQL database, return an array of all columns in the given table  source  #  BioMedQuery.DBUtils.select_columns     Method .  select_columns(db, table)  Return an array with names of columns in the given table  source", 
            "title": "Functions"
        }, 
        {
            "location": "/library/", 
            "text": "Index\n\n\n\n\nBioMedQuery.UMLS.Credentials\n\n\nBioMedQuery.DBUtils.assemble_cols_and_vals\n\n\nBioMedQuery.DBUtils.assemble_cols_and_vals_select\n\n\nBioMedQuery.DBUtils.assemble_vals\n\n\nBioMedQuery.DBUtils.colname_dict\n\n\nBioMedQuery.DBUtils.db_query\n\n\nBioMedQuery.DBUtils.db_query\n\n\nBioMedQuery.DBUtils.db_select\n\n\nBioMedQuery.DBUtils.init_mysql_database\n\n\nBioMedQuery.DBUtils.insert_row!\n\n\nBioMedQuery.DBUtils.insert_row!\n\n\nBioMedQuery.DBUtils.select_all_tables\n\n\nBioMedQuery.DBUtils.select_all_tables\n\n\nBioMedQuery.DBUtils.select_columns\n\n\nBioMedQuery.DBUtils.select_columns\n\n\nBioMedQuery.Entrez.DB.all_pmids\n\n\nBioMedQuery.Entrez.DB.get_article_mesh\n\n\nBioMedQuery.Entrez.efetch\n\n\nBioMedQuery.Entrez.elink\n\n\nBioMedQuery.Entrez.eparse\n\n\nBioMedQuery.Entrez.esearch\n\n\nBioMedQuery.Entrez.esummary\n\n\nBioMedQuery.Processes.export_citation\n\n\nBioMedQuery.Processes.export_citation\n\n\nBioMedQuery.Processes.map_mesh_to_umls!\n\n\nBioMedQuery.Processes.map_mesh_to_umls_async!\n\n\nBioMedQuery.Processes.pubmed_search_and_save\n\n\nBioMedQuery.Processes.umls_semantic_occurrences\n\n\nBioMedQuery.UMLS.best_match_cui\n\n\nBioMedQuery.UMLS.get_semantic_type\n\n\nBioMedQuery.UMLS.populate_net_mysql\n\n\nBioMedQuery.UMLS.search_umls", 
            "title": "Library"
        }, 
        {
            "location": "/library/#index", 
            "text": "BioMedQuery.UMLS.Credentials  BioMedQuery.DBUtils.assemble_cols_and_vals  BioMedQuery.DBUtils.assemble_cols_and_vals_select  BioMedQuery.DBUtils.assemble_vals  BioMedQuery.DBUtils.colname_dict  BioMedQuery.DBUtils.db_query  BioMedQuery.DBUtils.db_query  BioMedQuery.DBUtils.db_select  BioMedQuery.DBUtils.init_mysql_database  BioMedQuery.DBUtils.insert_row!  BioMedQuery.DBUtils.insert_row!  BioMedQuery.DBUtils.select_all_tables  BioMedQuery.DBUtils.select_all_tables  BioMedQuery.DBUtils.select_columns  BioMedQuery.DBUtils.select_columns  BioMedQuery.Entrez.DB.all_pmids  BioMedQuery.Entrez.DB.get_article_mesh  BioMedQuery.Entrez.efetch  BioMedQuery.Entrez.elink  BioMedQuery.Entrez.eparse  BioMedQuery.Entrez.esearch  BioMedQuery.Entrez.esummary  BioMedQuery.Processes.export_citation  BioMedQuery.Processes.export_citation  BioMedQuery.Processes.map_mesh_to_umls!  BioMedQuery.Processes.map_mesh_to_umls_async!  BioMedQuery.Processes.pubmed_search_and_save  BioMedQuery.Processes.umls_semantic_occurrences  BioMedQuery.UMLS.best_match_cui  BioMedQuery.UMLS.get_semantic_type  BioMedQuery.UMLS.populate_net_mysql  BioMedQuery.UMLS.search_umls", 
            "title": "Index"
        }
    ]
}