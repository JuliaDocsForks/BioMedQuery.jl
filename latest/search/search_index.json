{
    "docs": [
        {
            "location": "/", 
            "text": "BioMedQuery Julia Package\n\n\nJulia utilities to process and save results from BioMedical databases/APIs. \n\n\nBioServices.jl\n (part of BioJulia) provides the basic interface to some of the APIs, while BioMedQuery helps parse and save results into MySQL, SQLite, DataFrames etcs. \n\n\nSupported APIs include:\n\n\nNational Library of Medicine (NLM)\n\n\n\n\nEntrez Programming Utilities \n(E-Utilities)\n\n\nUnified Medical Language System \n(UMLS)\n\n\nClinical Trials \n(clinicaltrials.gov)\n\n\n\n\n\n\nInstallation\n\n\nBioMedQuery is a registered package. To install the latest \nstable version\n, use the package manager.\n\n\nPkg.add(\nBioMedQuery\n)\n\n\n\n\n\nTo chekout the current master (development) branch:\n\n\nPkg\n.\ncheckout\n(\nBioMedQuery\n)\n\n\n\n\n\n\n`\n\n\n\n\nRelated Packages\n\n\n\n\n\n\n\n\nFunction\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBioServices.jl\n\n\nInterface to EUtils and UMLS APIs\n\n\n\n\n\n\nPubMedMiner.jl\n\n\nExamples of comorbidity studies using PubMed artciles", 
            "title": "Home"
        }, 
        {
            "location": "/#biomedquery-julia-package", 
            "text": "Julia utilities to process and save results from BioMedical databases/APIs.   BioServices.jl  (part of BioJulia) provides the basic interface to some of the APIs, while BioMedQuery helps parse and save results into MySQL, SQLite, DataFrames etcs.   Supported APIs include:  National Library of Medicine (NLM)   Entrez Programming Utilities  (E-Utilities)  Unified Medical Language System  (UMLS)  Clinical Trials  (clinicaltrials.gov)", 
            "title": "BioMedQuery Julia Package"
        }, 
        {
            "location": "/#installation", 
            "text": "BioMedQuery is a registered package. To install the latest  stable version , use the package manager.  Pkg.add( BioMedQuery )  To chekout the current master (development) branch:  Pkg . checkout ( BioMedQuery )   `", 
            "title": "Installation"
        }, 
        {
            "location": "/#related-packages", 
            "text": "Function  Description      BioServices.jl  Interface to EUtils and UMLS APIs    PubMedMiner.jl  Examples of comorbidity studies using PubMed artciles", 
            "title": "Related Packages"
        }, 
        {
            "location": "/examples/", 
            "text": "The repository contains an \nexamples folder\n with jupyter notebooks demonstrating how to use BioMedQuery's pre-assembled high-level processes and workflows.\n\n\nNote: \n When working with the notebooks, a corresponding julia script is generated automatically on every save. For this feature to work properly, make sure you have \nnbconvert\n installed.\n\n\nThe following examples are available:\n\n\n\n\n\n\n\n\nExample\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nSearch and Save PubMed Queries\n\n\nSearch pubmed, parse results and store using MySQL or SQLite backend, or export to a  citation library\n\n\n\n\n\n\nBuild MESH-UMLS map\n\n\nFor all MeSH descriptors in a given database, build a table to match them to their UMLS concept\n\n\n\n\n\n\nOccurrence Matrix\n\n\nBuild a occurrence matrix indicating papers associated with MeSH descriptors of a given UMLS concept\n\n\n\n\n\n\nExporting Citations\n\n\nExport the citation for one or more PMIDs to a Endnote/Bibtex file", 
            "title": "Overview"
        }, 
        {
            "location": "/example1/", 
            "text": "", 
            "title": "Pubmed Search and Save"
        }, 
        {
            "location": "/example2/", 
            "text": "", 
            "title": "MeSH/UMLS Map"
        }, 
        {
            "location": "/example3/", 
            "text": "", 
            "title": "UMLS Semantic Filtering"
        }, 
        {
            "location": "/example4/", 
            "text": "", 
            "title": "Export to citations"
        }, 
        {
            "location": "/processes/", 
            "text": "This module provides common processes/workflows when using the BioMedQuery utilities. For instance, searching PubMed, requires calling the NCBI e-utils in a particular order. After the search, the results are often saved to the database. This module contains pre-assembled functions performing all necessary steps. To see sample scripts that use this processes, refer to the following \nsection\n\n\nImport\n\n\nusing BioMedQuery.Processes\n\n\n\n\n\n\n\nIndex\n\n\n\n\nBioMedQuery.Processes.export_citation\n\n\nBioMedQuery.Processes.export_citation\n\n\nBioMedQuery.Processes.map_mesh_to_umls!\n\n\nBioMedQuery.Processes.map_mesh_to_umls_async!\n\n\nBioMedQuery.Processes.pubmed_search_and_save\n\n\nBioMedQuery.Processes.pubmed_search_and_save_mysql!\n\n\nBioMedQuery.Processes.umls_semantic_occurrences\n\n\n\n\n\n\nFunctions\n\n\n#\n\n\nBioMedQuery.Processes.export_citation\n \n \nFunction\n.\n\n\nexport_citation(pmid::Int64, citation_type, output_file,verbose)\n\n\n\n\n\nExport, to an output file, the citation for PubMed article identified by the given pmid\n\n\nArguments\n\n\n\n\ncitation_type::String\n: At the moment supported types include: \"endnote\"\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.Processes.export_citation\n \n \nFunction\n.\n\n\nexport_citation(pmids::Vector{Int64}, citation_type, output_file,verbose)\n\n\n\n\n\nExport, to an output file, the citation for collection of PubMed articles identified by the given pmids\n\n\nArguments\n\n\n\n\ncitation_type::String\n: At the moment supported types include: \"endnote\"\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.Processes.map_mesh_to_umls!\n \n \nMethod\n.\n\n\nmap_mesh_to_umls!(db, c::Credentials)\n\n\nBuild and store in the given database a map from MESH descriptors to UMLS Semantic Concepts\n\n\nArguments\n\n\n\n\ndb\n: Database. Must contain TABLE:mesh_descriptor. For each of the\n\n\n\n\ndescriptors in that table, search and insert the associated semantic concepts into a new (cleared) TABLE:mesh2umls\n\n\n\n\nc::Credentials\n: UMLS username and password\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.Processes.map_mesh_to_umls_async!\n \n \nMethod\n.\n\n\nmap_mesh_to_umls_async\n!(\ndb\n,\n \nc\n::\nCredentials\n;\n \ntimeout\n,\n \nappend_results\n,\n \nverbose\n)\n\n\n\nBuild\n \n(\nusing\n \nasync\n \nUMLS-API\n \ncalls\n)\n \nand\n \nstore\n \nin\n \nthe\n \ngiven\n \ndatabase\n \na\n \nmap\n \nfrom\n\n\n\n\n\n\nMESH descriptors to UMLS Semantic Concepts. For large queies this function will be faster than it's synchrounous counterpart\n\n\nArguments\n\n\n\n\ndb\n: Database. Must contain TABLE:mesh_descriptor. For each of the\n\n\n\n\ndescriptors in that table, search and insert the associated semantic concepts into a new (cleared) TABLE:mesh2umls\n\n\n\n\nc::Credentials\n: UMLS username and password\n\n\nappend_results::Bool\n : If false a NEW and EMPTY mesh2umls database table in creted\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.Processes.pubmed_search_and_save\n \n \nFunction\n.\n\n\npubmed_search_and_save(email, search_term, article_max::Int64, db_path, verbose=false)\n\n\nArguments\n\n\n\n\nemail: valid email address (otherwise pubmed will block you)\n\n\nsearch_term : search string to submit to PubMed\n\n\n\n\ne.g (asthma[MeSH Terms]) AND (\"2001/01/29\"[Date - Publication] : \"2010\"[Date - Publication]) see http://www.ncbi.nlm.nih.gov/pubmed/advanced for help constructing the string\n\n\n\n\narticle_max : maximum number of articles to return\n\n\ndb_path: path to output database\n\n\nverbose: if true, the NCBI xml response files are saved to current directory\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.Processes.pubmed_search_and_save_mysql!\n \n \nFunction\n.\n\n\npubmed_search_and_save_mysql!(email, search_term::String, article_max,      con::MySQL.MySQLHandle, clean_efetch_tables = false, verbose=false)\n\n\nArguments\n\n\n\n\nemail\n: valid email address (otherwise pubmed will block you)\n\n\nsearch_term\n : search string to submit to PubMed\n\n\n\n\ne.g (asthma[MeSH Terms]) AND (\"2001/01/29\"[Date - Publication] : \"2010\"[Date - Publication]) see http://www.ncbi.nlm.nih.gov/pubmed/advanced for help constructing the string\n\n\n\n\narticle_max\n : maximum number of articles to return. Defaults to 600,000\n\n\ncon\n: MySQL connection\n\n\nclean_efetch_tables\n: If true the pubmed/efetch related tables are cleaned/overwritten\n\n\nverbose\n: if true, the NCBI xml response files are saved to current directory\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.Processes.umls_semantic_occurrences\n \n \nMethod\n.\n\n\numls_semantic_occurrences(db, umls_semantic_type)\n\n\nReturn a sparse matrix indicating the presence of MESH descriptors associated with a given umls semantic type in all articles of the input database\n\n\nOutput\n\n\n\n\ndes_ind_dict\n: Dictionary matching row number to descriptor names\n\n\ndisease_occurances\n : Sparse matrix. The columns correspond to a feature\n\n\n\n\nvector, where each row is a MESH descriptor. There are as many columns as articles. The occurance/abscense of a descriptor is labeled as 1/0\n\n\nsource", 
            "title": "Processes/Workflows"
        }, 
        {
            "location": "/processes/#import", 
            "text": "using BioMedQuery.Processes", 
            "title": "Import"
        }, 
        {
            "location": "/processes/#index", 
            "text": "BioMedQuery.Processes.export_citation  BioMedQuery.Processes.export_citation  BioMedQuery.Processes.map_mesh_to_umls!  BioMedQuery.Processes.map_mesh_to_umls_async!  BioMedQuery.Processes.pubmed_search_and_save  BioMedQuery.Processes.pubmed_search_and_save_mysql!  BioMedQuery.Processes.umls_semantic_occurrences", 
            "title": "Index"
        }, 
        {
            "location": "/processes/#functions", 
            "text": "#  BioMedQuery.Processes.export_citation     Function .  export_citation(pmid::Int64, citation_type, output_file,verbose)  Export, to an output file, the citation for PubMed article identified by the given pmid  Arguments   citation_type::String : At the moment supported types include: \"endnote\"   source  #  BioMedQuery.Processes.export_citation     Function .  export_citation(pmids::Vector{Int64}, citation_type, output_file,verbose)  Export, to an output file, the citation for collection of PubMed articles identified by the given pmids  Arguments   citation_type::String : At the moment supported types include: \"endnote\"   source  #  BioMedQuery.Processes.map_mesh_to_umls!     Method .  map_mesh_to_umls!(db, c::Credentials)  Build and store in the given database a map from MESH descriptors to UMLS Semantic Concepts", 
            "title": "Functions"
        }, 
        {
            "location": "/processes/#arguments", 
            "text": "db : Database. Must contain TABLE:mesh_descriptor. For each of the   descriptors in that table, search and insert the associated semantic concepts into a new (cleared) TABLE:mesh2umls   c::Credentials : UMLS username and password   source  #  BioMedQuery.Processes.map_mesh_to_umls_async!     Method .  map_mesh_to_umls_async !( db ,   c :: Credentials ;   timeout ,   append_results ,   verbose )  Build   ( using   async   UMLS-API   calls )   and   store   in   the   given   database   a   map   from   MESH descriptors to UMLS Semantic Concepts. For large queies this function will be faster than it's synchrounous counterpart", 
            "title": "Arguments"
        }, 
        {
            "location": "/processes/#arguments_1", 
            "text": "db : Database. Must contain TABLE:mesh_descriptor. For each of the   descriptors in that table, search and insert the associated semantic concepts into a new (cleared) TABLE:mesh2umls   c::Credentials : UMLS username and password  append_results::Bool  : If false a NEW and EMPTY mesh2umls database table in creted   source  #  BioMedQuery.Processes.pubmed_search_and_save     Function .  pubmed_search_and_save(email, search_term, article_max::Int64, db_path, verbose=false)", 
            "title": "Arguments"
        }, 
        {
            "location": "/processes/#arguments_2", 
            "text": "email: valid email address (otherwise pubmed will block you)  search_term : search string to submit to PubMed   e.g (asthma[MeSH Terms]) AND (\"2001/01/29\"[Date - Publication] : \"2010\"[Date - Publication]) see http://www.ncbi.nlm.nih.gov/pubmed/advanced for help constructing the string   article_max : maximum number of articles to return  db_path: path to output database  verbose: if true, the NCBI xml response files are saved to current directory   source  #  BioMedQuery.Processes.pubmed_search_and_save_mysql!     Function .  pubmed_search_and_save_mysql!(email, search_term::String, article_max,      con::MySQL.MySQLHandle, clean_efetch_tables = false, verbose=false)", 
            "title": "Arguments"
        }, 
        {
            "location": "/processes/#arguments_3", 
            "text": "email : valid email address (otherwise pubmed will block you)  search_term  : search string to submit to PubMed   e.g (asthma[MeSH Terms]) AND (\"2001/01/29\"[Date - Publication] : \"2010\"[Date - Publication]) see http://www.ncbi.nlm.nih.gov/pubmed/advanced for help constructing the string   article_max  : maximum number of articles to return. Defaults to 600,000  con : MySQL connection  clean_efetch_tables : If true the pubmed/efetch related tables are cleaned/overwritten  verbose : if true, the NCBI xml response files are saved to current directory   source  #  BioMedQuery.Processes.umls_semantic_occurrences     Method .  umls_semantic_occurrences(db, umls_semantic_type)  Return a sparse matrix indicating the presence of MESH descriptors associated with a given umls semantic type in all articles of the input database", 
            "title": "Arguments"
        }, 
        {
            "location": "/processes/#output", 
            "text": "des_ind_dict : Dictionary matching row number to descriptor names  disease_occurances  : Sparse matrix. The columns correspond to a feature   vector, where each row is a MESH descriptor. There are as many columns as articles. The occurance/abscense of a descriptor is labeled as 1/0  source", 
            "title": "Output"
        }, 
        {
            "location": "/pubmed/", 
            "text": "Utility functions to parse and store PubMed searches via \nBioServices.EUtils\n\n\n\n\nImport Module\n\n\nusing BioMedQuery.PubMed\n\n\n\n\n\nThis module provides utility functions to parse, store and export queries to PubMed via the NCBI EUtils and its julia interface \nBioServices.EUtils\n. For many purposes you may interact with the higher level pipelines in [BioMedQuery.Processes]. Here, some of the lower level functions are discussed in case you need to assemble different pipelines.\n\n\n\n\nBasics of searching PubMed\n\n\nWe are often interseted in searching PubMed for all articles related to a search term, and possibly restricted by other search criteria. To do so we use \nBioServices.EUtils\n. A basic example of how we may use the functions \nesearch\n and \nefetch\n to accomplish such task is illustrated below.\n\n\nusing\n \nBioServices\n.\nEUtils\n\n\nusing\n \nXMLDict\n\n\n\nsearch_term\n \n=\n \nobstructive sleep apnea[MeSH Major Topic]\n\n\n\n#esearch\n\n\nesearch_response\n \n=\n \nesearch\n(\ndb\n=\npubmed\n,\n \nterm\n \n=\n \nsearch_term\n,\n\n\nretstart\n \n=\n \n0\n,\n \nretmax\n \n=\n \n20\n,\n \ntool\n \n=\nBioJulia\n)\n\n\n\n#convert xml to dictionary\n\n\nesearch_dict\n \n=\n \nparse_xml\n(\nString\n(\nesearch_response\n.\ndata\n))\n\n\n\n#convert id\ns to a array of numbers\n\n\nids\n \n=\n \n[\nparse\n(\nInt64\n,\n \nid_node\n)\n \nfor\n \nid_node\n \nin\n \nesearch_dict\n[\nIdList\n][\nId\n]]\n\n\n\n#efetch\n\n\nefetch_response\n \n=\n \nefetch\n(\ndb\n \n=\n \npubmed\n,\n \ntool\n \n=\n \nBioJulia\n,\n \nretmode\n \n=\n \nxml\n,\n \nrettype\n \n=\n \nnull\n,\n \nid\n \n=\n \nids\n)\n\n\n\n#convert xml to dictionary\n\n\nefetch_dict\n \n=\n \nparse_xml\n(\nString\n(\nefetch_response\n.\ndata\n))\n\n\n\n\n\n\n\n\nHandling XML responses\n\n\nMany APIs return responses in XML form. \n\n\nTo parse an XML to a Julia dictionary we can use the XMLDict package\n\n\nusing\n \nXMLDict\n\n\ndict\n \n=\n \nparse_xml\n(\nString\n(\nresponse\n.\ndata\n))\n  \n\n\n\n\n\nYou can save directly the XML String to file using LightXML\n\n\nxdoc\n \n=\n \nparse_string\n(\nesearch\n)\n\n\nsave_file\n(\nxdoc\n,\n \n./file.xml\n)\n\n\n\n\n\n\n\n\n\n\nSave eseach/efetch responses\n\n\n\n\nSave PMIDs to MySQL\n\n\nIf we are only interseted in saving a list of PMIDs associated with a query, we can do so as follows\n\n\ndbname\n \n=\n \nentrez_test\n\n\nconfig\n \n=\n \nDict\n(\n:\nhost\n=\n127.0.0.1\n,\n \n:\ndbname\n=\ndbname\n,\n \n:\nusername\n=\nroot\n,\n\n\n:\npswd\n=\n,\n \n:\noverwrite\n=\ntrue\n)\n\n\ncon\n \n=\n \nPubMed\n.\nsave_pmid_mysql\n(\nids\n,\n \nconfig\n,\n \nfalse\n)\n\n\n\n# get array of PMIDS store in database\n\n\nall_pmids\n \n=\n \nBioMedQuery\n.\nPubMed\n.\nall_pmids\n(\ncon\n)\n\n\n\n\n\n\n\n\nExport efetch response as EndNote citation file\n\n\nWe can export the information returned by efetch as and EndNote/BibTex library file\n\n\nconfig\n \n=\n \nDict\n(\n:\ntype\n \n=\n \nendnote\n,\n \n:\noutput_file\n \n=\n \n./citations_temp.endnote\n,\n \n:\noverwrite\n=\ntrue\n)\n\n\nnsucceses\n \n=\n \nBioMedQuery\n.\nPubMed\n.\nsave_article_citations\n(\nefetch_dict\n,\n \nconfig\n,\n \nverbose\n)\n\n\n\n\n\n\n\n\nSave efetch response to MySQL database\n\n\nSave the information returned by efetch to a MySQL database\n\n\ndbname\n \n=\n \nentrez_test\n\n\nconfig\n \n=\n \nDict\n(\n:\nhost\n=\n127.0.0.1\n,\n \n:\ndbname\n=\ndbname\n,\n \n:\nusername\n=\nroot\n,\n\n\n:\npswd\n=\n,\n \n:\noverwrite\n=\ntrue\n)\n\n\n@time\n \ndb\n \n=\n \nBioMedQuery\n.\nPubMed\n.\nsave_efetch_mysql\n(\nefetch_dict\n,\n \nconfig\n,\n \nverbose\n)\n\n\n\n\n\n\n\n\nSave efetch response to SQLite database\n\n\nSave the information returned by efetch to a MySQL database\n\n\nverbose\n \n=\n \nfalse\n\n\ndb_path\n \n=\n \n./test_db.db\n\n\n\nconfig\n \n=\n \nDict\n(\n:\ndb_path\n=\n \ndb_path\n,\n \n:\noverwrite\n=\ntrue\n)\n\n\ndb\n \n=\n \nBioMedQuery\n.\nPubMed\n.\nsave_efetch_sqlite\n(\nefetch_dict\n,\n \nconfig\n,\n \nverbose\n)\n\n\n\n\n\n\n\n\nExploring output databases\n\n\nThe following schema has been used to store the results. If you are interested in having this module store additional fields, feel free to open an issue        \n\n\n\n\nWe can als eexplore the tables using BioMedQuery.DBUtils, e,g\n\n\ntables\n \n=\n \n[\nauthor\n,\n \nauthor2article\n,\n \nmesh_descriptor\n,\n\n\nmesh_qualifier\n,\n \nmesh_heading\n]\n\n\n\nfor\n \nt\n \nin\n \ntables\n\n    \nquery_str\n \n=\n \nSELECT * FROM \n*\nt\n*\n LIMIT 10;\n\n    \nq\n \n=\n \nBioMedQuery\n.\nDBUtils\n.\ndb_query\n(\ndb\n,\n \nquery_str\n)\n\n    \nprintln\n(\nq\n)\n\n\nend\n\n\n\n\n\n\n\n\n\n\nIndex\n\n\n\n\nBioMedQuery.PubMed.abstracts\n\n\nBioMedQuery.PubMed.abstracts_by_year\n\n\nBioMedQuery.PubMed.all_mesh\n\n\nBioMedQuery.PubMed.all_pmids\n\n\nBioMedQuery.PubMed.get_article_mesh\n\n\nBioMedQuery.PubMed.get_article_mesh_by_concept\n\n\nBioMedQuery.PubMed.pubmed_save_efetch!\n\n\nBioMedQuery.PubMed.save_efetch_mysql\n\n\nBioMedQuery.PubMed.save_efetch_mysql\n\n\nBioMedQuery.PubMed.save_efetch_sqlite\n\n\nBioMedQuery.PubMed.save_pmid_mysql\n\n\n\n\n\n\nStructs and Functions\n\n\n#\n\n\nBioMedQuery.PubMed.abstracts\n \n \nMethod\n.\n\n\nabstracts(db; local_medline=false)\n\n\nReturn all abstracts related to PMIDs in the database. If local_medline flag is set to true, it is assumed that db contains \narticle\n table with only PMIDs and all other info is available in a (same host) medline database\n\n\nsource\n\n\n#\n\n\nBioMedQuery.PubMed.abstracts_by_year\n \n \nMethod\n.\n\n\nabstracts_by_year(db, pub_year; local_medline=false)\n\n\nReturn all abstracts of article published in the given year. If local_medline flag is set to true, it is assumed that db contains \narticle\n table with only PMIDs and all other info is available in a (same host) medline database\n\n\nsource\n\n\n#\n\n\nBioMedQuery.PubMed.all_pmids\n \n \nMethod\n.\n\n\nall_pmids(db)\n\n\n\n\n\nReturn all PMIDs stored in the \narticle\n table of the input database\n\n\nsource\n\n\n#\n\n\nBioMedQuery.PubMed.get_article_mesh\n \n \nMethod\n.\n\n\nget_article_mesh(db, pmid)\n\n\n\n\n\nGet the all mesh-descriptors associated with a give article\n\n\nsource\n\n\n#\n\n\nBioMedQuery.PubMed.get_article_mesh_by_concept\n \n \nMethod\n.\n\n\nget_article_mesh_by_concept(db, pmid, umls_concepts...; local_medline)\n\n\n\n\n\nGet the all mesh-descriptors associated with a give article\n\n\nArgumets:\n\n\n\n\nquery_string: \"\" - assumes full set of results were saved by BioMedQuery directly from XML\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.PubMed.save_efetch_mysql\n \n \nFunction\n.\n\n\nsave_efetch_mysql(efetch_dict, con::MySQL.MySQLHandle, clean_efetch_tables = false, verbose=false)\n\n\nSave the results (dictionary) of an entrez fetch to a MySQL database.\n\n\nArguments:\n\n\n\n\nefetch_dict\n: Response dictionary from efetch\n\n\ncon::MySQL.MySQLHandle\n: Connection to MySQL database\n\n\nclean_efetch_tables\n: If true, all tables related to efetch results are dropped\n\n\nverbose\n: Boolean to turn on extra print statements\n\n\n\n\nExample\n\n\njulia db_config =  Dict(:host=\n\"localhost\", :dbname=\n\"test\", :username=\n\"root\", :pswd=\n\"\", :overwrite=\ntrue) db = save_efetch_mysql(efetch_dict, db_config)\n\n\nsource\n\n\n#\n\n\nBioMedQuery.PubMed.save_efetch_mysql\n \n \nMethod\n.\n\n\nsave_efetch_mysql(efetch_dict, db_config, verbose)\n\n\nSave the results (dictionary) of an entrez fetch to a MySQL database.\n\n\nArguments:\n\n\n\n\nefetch_dict\n: Response dictionary from efetch\n\n\ndb_config::Dict{Symbol, T}\n: Configuration dictionary for initialitizing SQLite\n\n\n\n\ndatabase. Must contain symbols \n:host\n, \n:dbname\n, \n:username\n. \npswd\n, and \n:overwrite\n\n\n\n\nverbose\n: Boolean to turn on extra print statements\n\n\n\n\nExample\n\n\ndb_config\n \n=\n  \nDict\n(\n:\nhost\n=\nlocalhost\n,\n \n:\ndbname\n=\ntest\n,\n \n:\nusername\n=\nroot\n,\n\n\n:\npswd\n=\n,\n \n:\noverwrite\n=\ntrue\n)\n\n\ndb\n \n=\n \nsave_efetch_mysql\n(\nefetch_dict\n,\n \ndb_config\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.PubMed.save_efetch_sqlite\n \n \nMethod\n.\n\n\nsave_efetch_sqlite(efetch_dict, db_config, verbose)\n\n\nSave the results (dictionary) of an entrez fetch to a SQLite database.\n\n\nArguments:\n\n\n\n\nefetch_dict\n: Response dictionary from efetch\n\n\ndb_config::Dict{Symbol, T}\n: Configuration dictionary for initialitizing SQLite\n\n\n\n\ndatabase. Must contain symbols \n:db_path\n and \n:overwrite\n\n\n\n\nverbose\n: Boolean to turn on extra print statements\n\n\n\n\nExample\n\n\ndb_config\n \n=\n  \nDict\n(\n:\ndb_path\n=\ntest_db.slqite\n,\n \n:\noverwrite\n=\ntrue\n)\n\n\ndb\n \n=\n \nsave_efetch_sqlite\n(\nefetch_dict\n,\n \ndb_config\n)\n\n\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.PubMed.save_pmid_mysql\n \n \nMethod\n.\n\n\nsave_pmid_mysql(pmids, db_config, verbose)\n\n\nSave a list of PMIDS into input database. ###Arguments:\n\n\n\n\npmids\n: Array of PMIDs\n\n\ndb_config::Dict{Symbol, T}\n: Configuration dictionary for initialitizing SQLite\n\n\n\n\ndatabase. Must contain symbols \n:host\n, \n:dbname\n, \n:username\n. \npswd\n, and \n:overwrite\n\n\n\n\nverbose\n: Boolean to turn on extra print statements\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.PubMed.all_mesh\n \n \nMethod\n.\n\n\nall_mesh(db)\n\n\n\n\n\nReturn all PMIDs stored in the \narticle\n table of the input database\n\n\nsource\n\n\n#\n\n\nBioMedQuery.PubMed.pubmed_save_efetch!\n \n \nFunction\n.\n\n\npubmed_save_efetch(efetch_dict, db_path)\n\n\nSave the results (dictionary) of an entrez-pubmed fetch to the input database.\n\n\nsource", 
            "title": "PubMed"
        }, 
        {
            "location": "/pubmed/#import-module", 
            "text": "using BioMedQuery.PubMed  This module provides utility functions to parse, store and export queries to PubMed via the NCBI EUtils and its julia interface  BioServices.EUtils . For many purposes you may interact with the higher level pipelines in [BioMedQuery.Processes]. Here, some of the lower level functions are discussed in case you need to assemble different pipelines.", 
            "title": "Import Module"
        }, 
        {
            "location": "/pubmed/#basics-of-searching-pubmed", 
            "text": "We are often interseted in searching PubMed for all articles related to a search term, and possibly restricted by other search criteria. To do so we use  BioServices.EUtils . A basic example of how we may use the functions  esearch  and  efetch  to accomplish such task is illustrated below.  using   BioServices . EUtils  using   XMLDict  search_term   =   obstructive sleep apnea[MeSH Major Topic]  #esearch  esearch_response   =   esearch ( db = pubmed ,   term   =   search_term ,  retstart   =   0 ,   retmax   =   20 ,   tool   = BioJulia )  #convert xml to dictionary  esearch_dict   =   parse_xml ( String ( esearch_response . data ))  #convert id s to a array of numbers  ids   =   [ parse ( Int64 ,   id_node )   for   id_node   in   esearch_dict [ IdList ][ Id ]]  #efetch  efetch_response   =   efetch ( db   =   pubmed ,   tool   =   BioJulia ,   retmode   =   xml ,   rettype   =   null ,   id   =   ids )  #convert xml to dictionary  efetch_dict   =   parse_xml ( String ( efetch_response . data ))", 
            "title": "Basics of searching PubMed"
        }, 
        {
            "location": "/pubmed/#handling-xml-responses", 
            "text": "Many APIs return responses in XML form.   To parse an XML to a Julia dictionary we can use the XMLDict package  using   XMLDict  dict   =   parse_xml ( String ( response . data ))     You can save directly the XML String to file using LightXML  xdoc   =   parse_string ( esearch )  save_file ( xdoc ,   ./file.xml )", 
            "title": "Handling XML responses"
        }, 
        {
            "location": "/pubmed/#save-eseachefetch-responses", 
            "text": "", 
            "title": "Save eseach/efetch responses"
        }, 
        {
            "location": "/pubmed/#save-pmids-to-mysql", 
            "text": "If we are only interseted in saving a list of PMIDs associated with a query, we can do so as follows  dbname   =   entrez_test  config   =   Dict ( : host = 127.0.0.1 ,   : dbname = dbname ,   : username = root ,  : pswd = ,   : overwrite = true )  con   =   PubMed . save_pmid_mysql ( ids ,   config ,   false )  # get array of PMIDS store in database  all_pmids   =   BioMedQuery . PubMed . all_pmids ( con )", 
            "title": "Save PMIDs to MySQL"
        }, 
        {
            "location": "/pubmed/#export-efetch-response-as-endnote-citation-file", 
            "text": "We can export the information returned by efetch as and EndNote/BibTex library file  config   =   Dict ( : type   =   endnote ,   : output_file   =   ./citations_temp.endnote ,   : overwrite = true )  nsucceses   =   BioMedQuery . PubMed . save_article_citations ( efetch_dict ,   config ,   verbose )", 
            "title": "Export efetch response as EndNote citation file"
        }, 
        {
            "location": "/pubmed/#save-efetch-response-to-mysql-database", 
            "text": "Save the information returned by efetch to a MySQL database  dbname   =   entrez_test  config   =   Dict ( : host = 127.0.0.1 ,   : dbname = dbname ,   : username = root ,  : pswd = ,   : overwrite = true )  @time   db   =   BioMedQuery . PubMed . save_efetch_mysql ( efetch_dict ,   config ,   verbose )", 
            "title": "Save efetch response to MySQL database"
        }, 
        {
            "location": "/pubmed/#save-efetch-response-to-sqlite-database", 
            "text": "Save the information returned by efetch to a MySQL database  verbose   =   false  db_path   =   ./test_db.db  config   =   Dict ( : db_path =   db_path ,   : overwrite = true )  db   =   BioMedQuery . PubMed . save_efetch_sqlite ( efetch_dict ,   config ,   verbose )", 
            "title": "Save efetch response to SQLite database"
        }, 
        {
            "location": "/pubmed/#exploring-output-databases", 
            "text": "The following schema has been used to store the results. If you are interested in having this module store additional fields, feel free to open an issue           We can als eexplore the tables using BioMedQuery.DBUtils, e,g  tables   =   [ author ,   author2article ,   mesh_descriptor ,  mesh_qualifier ,   mesh_heading ]  for   t   in   tables \n     query_str   =   SELECT * FROM  * t *  LIMIT 10; \n     q   =   BioMedQuery . DBUtils . db_query ( db ,   query_str ) \n     println ( q )  end", 
            "title": "Exploring output databases"
        }, 
        {
            "location": "/pubmed/#index", 
            "text": "BioMedQuery.PubMed.abstracts  BioMedQuery.PubMed.abstracts_by_year  BioMedQuery.PubMed.all_mesh  BioMedQuery.PubMed.all_pmids  BioMedQuery.PubMed.get_article_mesh  BioMedQuery.PubMed.get_article_mesh_by_concept  BioMedQuery.PubMed.pubmed_save_efetch!  BioMedQuery.PubMed.save_efetch_mysql  BioMedQuery.PubMed.save_efetch_mysql  BioMedQuery.PubMed.save_efetch_sqlite  BioMedQuery.PubMed.save_pmid_mysql", 
            "title": "Index"
        }, 
        {
            "location": "/pubmed/#structs-and-functions", 
            "text": "#  BioMedQuery.PubMed.abstracts     Method .  abstracts(db; local_medline=false)  Return all abstracts related to PMIDs in the database. If local_medline flag is set to true, it is assumed that db contains  article  table with only PMIDs and all other info is available in a (same host) medline database  source  #  BioMedQuery.PubMed.abstracts_by_year     Method .  abstracts_by_year(db, pub_year; local_medline=false)  Return all abstracts of article published in the given year. If local_medline flag is set to true, it is assumed that db contains  article  table with only PMIDs and all other info is available in a (same host) medline database  source  #  BioMedQuery.PubMed.all_pmids     Method .  all_pmids(db)  Return all PMIDs stored in the  article  table of the input database  source  #  BioMedQuery.PubMed.get_article_mesh     Method .  get_article_mesh(db, pmid)  Get the all mesh-descriptors associated with a give article  source  #  BioMedQuery.PubMed.get_article_mesh_by_concept     Method .  get_article_mesh_by_concept(db, pmid, umls_concepts...; local_medline)  Get the all mesh-descriptors associated with a give article  Argumets:   query_string: \"\" - assumes full set of results were saved by BioMedQuery directly from XML   source  #  BioMedQuery.PubMed.save_efetch_mysql     Function .  save_efetch_mysql(efetch_dict, con::MySQL.MySQLHandle, clean_efetch_tables = false, verbose=false)  Save the results (dictionary) of an entrez fetch to a MySQL database.", 
            "title": "Structs and Functions"
        }, 
        {
            "location": "/pubmed/#arguments", 
            "text": "efetch_dict : Response dictionary from efetch  con::MySQL.MySQLHandle : Connection to MySQL database  clean_efetch_tables : If true, all tables related to efetch results are dropped  verbose : Boolean to turn on extra print statements", 
            "title": "Arguments:"
        }, 
        {
            "location": "/pubmed/#example", 
            "text": "julia db_config =  Dict(:host= \"localhost\", :dbname= \"test\", :username= \"root\", :pswd= \"\", :overwrite= true) db = save_efetch_mysql(efetch_dict, db_config)  source  #  BioMedQuery.PubMed.save_efetch_mysql     Method .  save_efetch_mysql(efetch_dict, db_config, verbose)  Save the results (dictionary) of an entrez fetch to a MySQL database.", 
            "title": "Example"
        }, 
        {
            "location": "/pubmed/#arguments_1", 
            "text": "efetch_dict : Response dictionary from efetch  db_config::Dict{Symbol, T} : Configuration dictionary for initialitizing SQLite   database. Must contain symbols  :host ,  :dbname ,  :username .  pswd , and  :overwrite   verbose : Boolean to turn on extra print statements", 
            "title": "Arguments:"
        }, 
        {
            "location": "/pubmed/#example_1", 
            "text": "db_config   =    Dict ( : host = localhost ,   : dbname = test ,   : username = root ,  : pswd = ,   : overwrite = true )  db   =   save_efetch_mysql ( efetch_dict ,   db_config )   source  #  BioMedQuery.PubMed.save_efetch_sqlite     Method .  save_efetch_sqlite(efetch_dict, db_config, verbose)  Save the results (dictionary) of an entrez fetch to a SQLite database.", 
            "title": "Example"
        }, 
        {
            "location": "/pubmed/#arguments_2", 
            "text": "efetch_dict : Response dictionary from efetch  db_config::Dict{Symbol, T} : Configuration dictionary for initialitizing SQLite   database. Must contain symbols  :db_path  and  :overwrite   verbose : Boolean to turn on extra print statements", 
            "title": "Arguments:"
        }, 
        {
            "location": "/pubmed/#example_2", 
            "text": "db_config   =    Dict ( : db_path = test_db.slqite ,   : overwrite = true )  db   =   save_efetch_sqlite ( efetch_dict ,   db_config )   source  #  BioMedQuery.PubMed.save_pmid_mysql     Method .  save_pmid_mysql(pmids, db_config, verbose)  Save a list of PMIDS into input database. ###Arguments:   pmids : Array of PMIDs  db_config::Dict{Symbol, T} : Configuration dictionary for initialitizing SQLite   database. Must contain symbols  :host ,  :dbname ,  :username .  pswd , and  :overwrite   verbose : Boolean to turn on extra print statements   source  #  BioMedQuery.PubMed.all_mesh     Method .  all_mesh(db)  Return all PMIDs stored in the  article  table of the input database  source  #  BioMedQuery.PubMed.pubmed_save_efetch!     Function .  pubmed_save_efetch(efetch_dict, db_path)  Save the results (dictionary) of an entrez-pubmed fetch to the input database.  source", 
            "title": "Example"
        }, 
        {
            "location": "/ct/", 
            "text": "Submit and save queries to \nclinicaltrials.gov\n\n\nImport\n\n\nusing NLM.CT\n\n\n\n\n\n\n\nSearch and save\n\n\n\n\nCreate a query:\n\n\nquery = Dict(\nterm\n =\n \nacne\n, \nage\n=\nInt(CT.child), \nlocn\n =\n \nNew York, NY\n)\n\n\n\n\n\nNote: The term can also indicate joint searches, e.g.\n\n\nterm\n =\n \naspirin OR ibuprofen\n\n\n\n\n\n\n\n\nSubmit and save:\n\n\nfout= \n./test_CT_search.zip\n\nstatus = NLM.CT.search_ct(query, fout;)", 
            "title": "Clinical Trials"
        }, 
        {
            "location": "/ct/#import", 
            "text": "using NLM.CT", 
            "title": "Import"
        }, 
        {
            "location": "/ct/#search-and-save", 
            "text": "", 
            "title": "Search and save"
        }, 
        {
            "location": "/ct/#create-a-query", 
            "text": "query = Dict( term  =   acne ,  age = Int(CT.child),  locn  =   New York, NY )  Note: The term can also indicate joint searches, e.g.  term  =   aspirin OR ibuprofen", 
            "title": "Create a query:"
        }, 
        {
            "location": "/ct/#submit-and-save", 
            "text": "fout=  ./test_CT_search.zip \nstatus = NLM.CT.search_ct(query, fout;)", 
            "title": "Submit and save:"
        }, 
        {
            "location": "/dbutils/", 
            "text": "Collection of functions that extend of simplify interactions with MySQL and SQLite databases\n\n\n\n\nImport Module\n\n\nusing BioMedQuery.DBUtils\n\n\n\n\n\n\n\nIndex\n\n\n\n\nBioMedQuery.DBUtils.assemble_cols_and_vals\n\n\nBioMedQuery.DBUtils.assemble_cols_and_vals_string\n\n\nBioMedQuery.DBUtils.assemble_vals\n\n\nBioMedQuery.DBUtils.colname_dict\n\n\nBioMedQuery.DBUtils.db_query\n\n\nBioMedQuery.DBUtils.db_query\n\n\nBioMedQuery.DBUtils.db_select\n\n\nBioMedQuery.DBUtils.init_mysql_database\n\n\nBioMedQuery.DBUtils.insert_row!\n\n\nBioMedQuery.DBUtils.insert_row!\n\n\nBioMedQuery.DBUtils.select_all_tables\n\n\nBioMedQuery.DBUtils.select_all_tables\n\n\nBioMedQuery.DBUtils.select_columns\n\n\nBioMedQuery.DBUtils.select_columns\n\n\n\n\n\n\nFunctions\n\n\n#\n\n\nBioMedQuery.DBUtils.assemble_cols_and_vals\n \n \nMethod\n.\n\n\nassemble_vals(data_values)\n\n\n\n\n\nGiven a dictionary containg (:column=\nvalue) return a single string properly formatted for a MySQL insert. E.g MySQL requires CHAR or other non-numeric values be passed with single quotes around them.\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.assemble_cols_and_vals_string\n \n \nMethod\n.\n\n\nassemble_vals(data_values)\n\n\n\n\n\nGiven a dictionary containg (:column=\nvalue), return a single string properly formatted for a MySQL SELECT. E.g MySQL requires CHAR or other non-numeric values be passed with single quotes around them.\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.assemble_vals\n \n \nMethod\n.\n\n\nassemble_vals(data_values, column_names)\n\n\n\n\n\nGiven a Dict of values and the column names, return a single string properly formatted for a MySQL INSERT. E.g MySQL requires CHAR or other non-numeric values be passed with single quotes around them.\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.db_query\n \n \nMethod\n.\n\n\nquery_mysql(con, query_code)\n\n\n\n\n\nExecute a mysql command\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.db_query\n \n \nMethod\n.\n\n\nquery(db, query_code)\n\n\n\n\n\nExecute a SQLite command\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.db_select\n \n \nMethod\n.\n\n\nselect_(con, colnames, tablename, data_values)\n\n\n\n\n\nPerform: SELECT colnames tablename WHERE keys(data_values)=values(data_values)\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.init_mysql_database\n \n \nMethod\n.\n\n\ninit_mysql_database(;host = \n127.0.0.1\n, dbname=\ntest\n,\nusername=\nroot\n, pswd=\n, mysql_code=nothing, overwrite=false)\n\n\n\n\n\nCreate a MySQL database using the code inside mysql_code\n\n\nArguments\n\n\n\n\nhost\n, \ndbname\n, \nuser\n, \npswd\n\n\nmysql_code::String\n: String with MySQL code that crates all default tables\n\n\noverwrite::Bool\n : Flag, if true and dbname exists, drops all database and re-creates it\n\n\n\n\nOutput\n\n\n\n\ncon\n: Database connection and table-column names map\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.insert_row!\n \n \nMethod\n.\n\n\ninsert_row!(db, tablename, values)\n\n\n\n\n\nInsert a row of values into the specified table for a given a MySQL database handle\n\n\nArguments:\n\n\n\n\ndb::MySQLDB\n: Database object (connection and map)\n\n\ndata_values::Dict{String, Any}\n: Array of (string) values\n\n\nverbose\n: Print debugginh info\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.insert_row!\n \n \nMethod\n.\n\n\ninsert_row!(db, tablename, values)\n\n\n\n\n\nInsert a row of values into the specified table for a given a SQLite database handle\n\n\nArguments:\n\n\n\n\ndb::MySQLDB\n: Database object (connection and map)\n\n\ndata_values::Dict{String, Any}\n: Array of (string) values\n\n\nverbose\n: Print debugginh info\n\n\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.colname_dict\n \n \nMethod\n.\n\n\ncolname_dict_(con)\n\n\n\n\n\nReturn a dictionary maping tables and their columns for a given MySQL-connection/SQLite-database\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.select_all_tables\n \n \nMethod\n.\n\n\nselect_all_tables_mysql(con)\n\n\n\n\n\nReturn an array of all tables in a given MySQL database\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.select_all_tables\n \n \nMethod\n.\n\n\nselect_all_tables_mysql(con)\n\n\n\n\n\nReturn an array of all tables in a given MySQL database\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.select_columns\n \n \nMethod\n.\n\n\nselect_columns_mysql(con, table)\n\n\n\n\n\nFor a MySQL database, return an array of all columns in the given table\n\n\nsource\n\n\n#\n\n\nBioMedQuery.DBUtils.select_columns\n \n \nMethod\n.\n\n\nselect_columns(db, table)\n\n\n\n\n\nReturn an array with names of columns in the given table\n\n\nsource", 
            "title": "Database Utilities"
        }, 
        {
            "location": "/dbutils/#import-module", 
            "text": "using BioMedQuery.DBUtils", 
            "title": "Import Module"
        }, 
        {
            "location": "/dbutils/#index", 
            "text": "BioMedQuery.DBUtils.assemble_cols_and_vals  BioMedQuery.DBUtils.assemble_cols_and_vals_string  BioMedQuery.DBUtils.assemble_vals  BioMedQuery.DBUtils.colname_dict  BioMedQuery.DBUtils.db_query  BioMedQuery.DBUtils.db_query  BioMedQuery.DBUtils.db_select  BioMedQuery.DBUtils.init_mysql_database  BioMedQuery.DBUtils.insert_row!  BioMedQuery.DBUtils.insert_row!  BioMedQuery.DBUtils.select_all_tables  BioMedQuery.DBUtils.select_all_tables  BioMedQuery.DBUtils.select_columns  BioMedQuery.DBUtils.select_columns", 
            "title": "Index"
        }, 
        {
            "location": "/dbutils/#functions", 
            "text": "#  BioMedQuery.DBUtils.assemble_cols_and_vals     Method .  assemble_vals(data_values)  Given a dictionary containg (:column= value) return a single string properly formatted for a MySQL insert. E.g MySQL requires CHAR or other non-numeric values be passed with single quotes around them.  source  #  BioMedQuery.DBUtils.assemble_cols_and_vals_string     Method .  assemble_vals(data_values)  Given a dictionary containg (:column= value), return a single string properly formatted for a MySQL SELECT. E.g MySQL requires CHAR or other non-numeric values be passed with single quotes around them.  source  #  BioMedQuery.DBUtils.assemble_vals     Method .  assemble_vals(data_values, column_names)  Given a Dict of values and the column names, return a single string properly formatted for a MySQL INSERT. E.g MySQL requires CHAR or other non-numeric values be passed with single quotes around them.  source  #  BioMedQuery.DBUtils.db_query     Method .  query_mysql(con, query_code)  Execute a mysql command  source  #  BioMedQuery.DBUtils.db_query     Method .  query(db, query_code)  Execute a SQLite command  source  #  BioMedQuery.DBUtils.db_select     Method .  select_(con, colnames, tablename, data_values)  Perform: SELECT colnames tablename WHERE keys(data_values)=values(data_values)  source  #  BioMedQuery.DBUtils.init_mysql_database     Method .  init_mysql_database(;host =  127.0.0.1 , dbname= test ,\nusername= root , pswd= , mysql_code=nothing, overwrite=false)  Create a MySQL database using the code inside mysql_code  Arguments   host ,  dbname ,  user ,  pswd  mysql_code::String : String with MySQL code that crates all default tables  overwrite::Bool  : Flag, if true and dbname exists, drops all database and re-creates it   Output   con : Database connection and table-column names map   source  #  BioMedQuery.DBUtils.insert_row!     Method .  insert_row!(db, tablename, values)  Insert a row of values into the specified table for a given a MySQL database handle  Arguments:   db::MySQLDB : Database object (connection and map)  data_values::Dict{String, Any} : Array of (string) values  verbose : Print debugginh info   source  #  BioMedQuery.DBUtils.insert_row!     Method .  insert_row!(db, tablename, values)  Insert a row of values into the specified table for a given a SQLite database handle  Arguments:   db::MySQLDB : Database object (connection and map)  data_values::Dict{String, Any} : Array of (string) values  verbose : Print debugginh info   source  #  BioMedQuery.DBUtils.colname_dict     Method .  colname_dict_(con)  Return a dictionary maping tables and their columns for a given MySQL-connection/SQLite-database  source  #  BioMedQuery.DBUtils.select_all_tables     Method .  select_all_tables_mysql(con)  Return an array of all tables in a given MySQL database  source  #  BioMedQuery.DBUtils.select_all_tables     Method .  select_all_tables_mysql(con)  Return an array of all tables in a given MySQL database  source  #  BioMedQuery.DBUtils.select_columns     Method .  select_columns_mysql(con, table)  For a MySQL database, return an array of all columns in the given table  source  #  BioMedQuery.DBUtils.select_columns     Method .  select_columns(db, table)  Return an array with names of columns in the given table  source", 
            "title": "Functions"
        }, 
        {
            "location": "/library/", 
            "text": "Index\n\n\n\n\nBioMedQuery.DBUtils.assemble_cols_and_vals\n\n\nBioMedQuery.DBUtils.assemble_cols_and_vals_string\n\n\nBioMedQuery.DBUtils.assemble_vals\n\n\nBioMedQuery.DBUtils.colname_dict\n\n\nBioMedQuery.DBUtils.db_query\n\n\nBioMedQuery.DBUtils.db_query\n\n\nBioMedQuery.DBUtils.db_select\n\n\nBioMedQuery.DBUtils.init_mysql_database\n\n\nBioMedQuery.DBUtils.insert_row!\n\n\nBioMedQuery.DBUtils.insert_row!\n\n\nBioMedQuery.DBUtils.select_all_tables\n\n\nBioMedQuery.DBUtils.select_all_tables\n\n\nBioMedQuery.DBUtils.select_columns\n\n\nBioMedQuery.DBUtils.select_columns\n\n\nBioMedQuery.Processes.export_citation\n\n\nBioMedQuery.Processes.export_citation\n\n\nBioMedQuery.Processes.map_mesh_to_umls!\n\n\nBioMedQuery.Processes.map_mesh_to_umls_async!\n\n\nBioMedQuery.Processes.pubmed_search_and_save\n\n\nBioMedQuery.Processes.pubmed_search_and_save_mysql!\n\n\nBioMedQuery.Processes.umls_semantic_occurrences\n\n\nBioMedQuery.PubMed.abstracts\n\n\nBioMedQuery.PubMed.abstracts_by_year\n\n\nBioMedQuery.PubMed.all_mesh\n\n\nBioMedQuery.PubMed.all_pmids\n\n\nBioMedQuery.PubMed.get_article_mesh\n\n\nBioMedQuery.PubMed.get_article_mesh_by_concept\n\n\nBioMedQuery.PubMed.pubmed_save_efetch!\n\n\nBioMedQuery.PubMed.save_efetch_mysql\n\n\nBioMedQuery.PubMed.save_efetch_mysql\n\n\nBioMedQuery.PubMed.save_efetch_sqlite\n\n\nBioMedQuery.PubMed.save_pmid_mysql", 
            "title": "Library"
        }, 
        {
            "location": "/library/#index", 
            "text": "BioMedQuery.DBUtils.assemble_cols_and_vals  BioMedQuery.DBUtils.assemble_cols_and_vals_string  BioMedQuery.DBUtils.assemble_vals  BioMedQuery.DBUtils.colname_dict  BioMedQuery.DBUtils.db_query  BioMedQuery.DBUtils.db_query  BioMedQuery.DBUtils.db_select  BioMedQuery.DBUtils.init_mysql_database  BioMedQuery.DBUtils.insert_row!  BioMedQuery.DBUtils.insert_row!  BioMedQuery.DBUtils.select_all_tables  BioMedQuery.DBUtils.select_all_tables  BioMedQuery.DBUtils.select_columns  BioMedQuery.DBUtils.select_columns  BioMedQuery.Processes.export_citation  BioMedQuery.Processes.export_citation  BioMedQuery.Processes.map_mesh_to_umls!  BioMedQuery.Processes.map_mesh_to_umls_async!  BioMedQuery.Processes.pubmed_search_and_save  BioMedQuery.Processes.pubmed_search_and_save_mysql!  BioMedQuery.Processes.umls_semantic_occurrences  BioMedQuery.PubMed.abstracts  BioMedQuery.PubMed.abstracts_by_year  BioMedQuery.PubMed.all_mesh  BioMedQuery.PubMed.all_pmids  BioMedQuery.PubMed.get_article_mesh  BioMedQuery.PubMed.get_article_mesh_by_concept  BioMedQuery.PubMed.pubmed_save_efetch!  BioMedQuery.PubMed.save_efetch_mysql  BioMedQuery.PubMed.save_efetch_mysql  BioMedQuery.PubMed.save_efetch_sqlite  BioMedQuery.PubMed.save_pmid_mysql", 
            "title": "Index"
        }
    ]
}